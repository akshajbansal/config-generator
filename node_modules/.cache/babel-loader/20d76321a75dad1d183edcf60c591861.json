{"ast":null,"code":"import { __assign } from \"tslib\";\nimport * as React from 'react';\nimport { useId, useControllableValue, useConst, useSetTimeout } from '@fluentui/react-hooks';\nimport { KeyCodes, css, getRTL, getRTLSafeKeyCode, on, classNamesFunction, getNativeProps, divProperties } from '@fluentui/utilities';\nexport var ONKEYDOWN_TIMEOUT_DURATION = 1000;\nvar getClassNames = classNamesFunction();\n\nvar getSlotStyleFn = function (sty) {\n  return function (value) {\n    var _a;\n\n    return _a = {}, _a[sty] = value + \"%\", _a;\n  };\n};\n\nvar getPercent = function (value, sliderMin, sliderMax) {\n  return sliderMax === sliderMin ? 0 : (value - sliderMin) / (sliderMax - sliderMin) * 100;\n};\n\nvar useComponentRef = function (props, thumb, value, range) {\n  React.useImperativeHandle(props.componentRef, function () {\n    return {\n      get value() {\n        return value;\n      },\n\n      get range() {\n        return range;\n      },\n\n      focus: function () {\n        if (thumb.current) {\n          thumb.current.focus();\n        }\n      }\n    };\n  }, [thumb, value, range]);\n};\n\nexport var useSlider = function (props, ref) {\n  var _a = props.step,\n      step = _a === void 0 ? 1 : _a,\n      className = props.className,\n      _b = props.disabled,\n      disabled = _b === void 0 ? false : _b,\n      label = props.label,\n      _c = props.max,\n      max = _c === void 0 ? 10 : _c,\n      _d = props.min,\n      min = _d === void 0 ? 0 : _d,\n      _e = props.showValue,\n      showValue = _e === void 0 ? true : _e,\n      _f = props.buttonProps,\n      buttonProps = _f === void 0 ? {} : _f,\n      _g = props.vertical,\n      vertical = _g === void 0 ? false : _g,\n      snapToStep = props.snapToStep,\n      valueFormat = props.valueFormat,\n      styles = props.styles,\n      theme = props.theme,\n      originFromZero = props.originFromZero,\n      ariaLabel = props[\"aria-label\"],\n      ranged = props.ranged,\n      onChange = props.onChange,\n      onChanged = props.onChanged;\n  var disposables = React.useRef([]);\n\n  var _h = useSetTimeout(),\n      setTimeout = _h.setTimeout,\n      clearTimeout = _h.clearTimeout;\n\n  var sliderLine = React.useRef(null); // Casting here is necessary because useControllableValue expects the event for the change callback\n  // to extend React.SyntheticEvent, when in fact for Slider, the event could be either a React event\n  // or a native browser event depending on the context.\n\n  var _j = useControllableValue(props.value, props.defaultValue, function (ev, v) {\n    return onChange === null || onChange === void 0 ? void 0 : onChange(v, ranged ? [internalState.latestLowerValue, v] : undefined, ev);\n  }),\n      unclampedValue = _j[0],\n      setValue = _j[1];\n\n  var _k = useControllableValue(props.lowerValue, props.defaultLowerValue, function (ev, lv) {\n    return onChange === null || onChange === void 0 ? void 0 : onChange(internalState.latestValue, [lv, internalState.latestValue], ev);\n  }),\n      unclampedLowerValue = _k[0],\n      setLowerValue = _k[1]; // Ensure that value is always a number and is clamped by min/max.\n\n\n  var value = Math.max(min, Math.min(max, unclampedValue || 0));\n  var lowerValue = Math.max(min, Math.min(value, unclampedLowerValue || 0));\n  var internalState = useConst({\n    onKeyDownTimer: -1,\n    isAdjustingLowerValue: false,\n    latestValue: value,\n    latestLowerValue: lowerValue\n  }); // On each render, update this saved value used by callbacks. (This should be safe even if render\n  // is called multiple times, because an event handler or timeout callback will only run once.)\n\n  internalState.latestValue = value;\n  internalState.latestLowerValue = lowerValue;\n  var id = useId('Slider', props.id || (buttonProps === null || buttonProps === void 0 ? void 0 : buttonProps.id));\n  var classNames = getClassNames(styles, {\n    className: className,\n    disabled: disabled,\n    vertical: vertical,\n    showTransitions: !snapToStep && !internalState.isBetweenSteps,\n    showValue: showValue,\n    ranged: ranged,\n    theme: theme\n  });\n  var steps = (max - min) / step;\n\n  var clearOnKeyDownTimer = function () {\n    clearTimeout(internalState.onKeyDownTimer);\n    internalState.onKeyDownTimer = -1;\n  };\n\n  var setOnKeyDownTimer = function (event) {\n    clearOnKeyDownTimer();\n\n    if (onChanged) {\n      internalState.onKeyDownTimer = setTimeout(function () {\n        onChanged(event, internalState.latestValue, ranged ? [internalState.latestLowerValue, internalState.latestValue] : undefined);\n      }, ONKEYDOWN_TIMEOUT_DURATION);\n    }\n  };\n\n  var getAriaValueText = function (valueProps) {\n    var ariaValueText = props.ariaValueText;\n\n    if (valueProps !== undefined) {\n      return ariaValueText ? ariaValueText(valueProps) : valueProps.toString();\n    }\n\n    return undefined;\n  };\n  /**\n   * Update `value` or `lowerValue`, including clamping between min/max and rounding to\n   * appropriate precision.\n   * @param newValue - New current value of the slider, possibly rounded to a whole step.\n   * @param newUnroundedValue - Like `newValue` but without the rounding to a step. If this is\n   * provided and not equal to `newValue`, `internalState.isBetweenSteps` will be set, which\n   * may cause thumb movement animations to be disabled.\n   */\n\n\n  var updateValue = function (ev, newValue, newUnroundedValue) {\n    newValue = Math.min(max, Math.max(min, newValue));\n    newUnroundedValue = newUnroundedValue !== undefined ? Math.min(max, Math.max(min, newUnroundedValue)) : undefined;\n    var numDec = 0;\n\n    if (isFinite(step)) {\n      while (Math.round(step * Math.pow(10, numDec)) / Math.pow(10, numDec) !== step) {\n        numDec++;\n      }\n    } // Make sure value has correct number of decimal places based on number of decimals in step\n\n\n    var roundedValue = parseFloat(newValue.toFixed(numDec));\n    internalState.isBetweenSteps = newUnroundedValue !== undefined && newUnroundedValue !== roundedValue;\n\n    if (ranged) {\n      // decided which thumb value to change\n      if (internalState.isAdjustingLowerValue && (originFromZero ? roundedValue <= 0 : roundedValue <= internalState.latestValue)) {\n        setLowerValue(roundedValue, ev);\n      } else if (!internalState.isAdjustingLowerValue && (originFromZero ? roundedValue >= 0 : roundedValue >= internalState.latestLowerValue)) {\n        setValue(roundedValue, ev);\n      }\n    } else {\n      setValue(roundedValue, ev);\n    }\n  };\n\n  var onKeyDown = function (event) {\n    var newCurrentValue = internalState.isAdjustingLowerValue ? internalState.latestLowerValue : internalState.latestValue;\n    var diff = 0; // eslint-disable-next-line deprecation/deprecation\n\n    switch (event.which) {\n      case getRTLSafeKeyCode(KeyCodes.left, props.theme):\n      case KeyCodes.down:\n        diff = -step;\n        clearOnKeyDownTimer();\n        setOnKeyDownTimer(event);\n        break;\n\n      case getRTLSafeKeyCode(KeyCodes.right, props.theme):\n      case KeyCodes.up:\n        diff = step;\n        clearOnKeyDownTimer();\n        setOnKeyDownTimer(event);\n        break;\n\n      case KeyCodes.home:\n        newCurrentValue = min;\n        clearOnKeyDownTimer();\n        setOnKeyDownTimer(event);\n        break;\n\n      case KeyCodes.end:\n        newCurrentValue = max;\n        clearOnKeyDownTimer();\n        setOnKeyDownTimer(event);\n        break;\n\n      default:\n        return;\n    }\n\n    updateValue(event, newCurrentValue + diff);\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  var getPosition = function (event, verticalProp) {\n    var currentPosition = 0;\n\n    switch (event.type) {\n      case 'mousedown':\n      case 'mousemove':\n        currentPosition = !verticalProp ? event.clientX : event.clientY;\n        break;\n\n      case 'touchstart':\n      case 'touchmove':\n        currentPosition = !verticalProp ? event.touches[0].clientX : event.touches[0].clientY;\n        break;\n    }\n\n    return currentPosition;\n  };\n\n  var calculateCurrentSteps = function (event) {\n    var sliderPositionRect = sliderLine.current.getBoundingClientRect();\n    var sliderLength = !props.vertical ? sliderPositionRect.width : sliderPositionRect.height;\n    var stepLength = sliderLength / steps;\n    var currentSteps;\n    var distance;\n\n    if (!props.vertical) {\n      var left = getPosition(event, props.vertical);\n      distance = getRTL(props.theme) ? sliderPositionRect.right - left : left - sliderPositionRect.left;\n      currentSteps = distance / stepLength;\n    } else {\n      var bottom = getPosition(event, props.vertical);\n      distance = sliderPositionRect.bottom - bottom;\n      currentSteps = distance / stepLength;\n    }\n\n    return currentSteps;\n  };\n\n  var onMouseMoveOrTouchMove = function (event, suppressEventCancelation) {\n    var currentSteps = calculateCurrentSteps(event);\n    var newUnroundedValue = min + step * currentSteps;\n    var newCurrentValue = min + step * Math.round(currentSteps);\n    updateValue(event, newCurrentValue, newUnroundedValue);\n\n    if (!suppressEventCancelation) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  };\n\n  var onMouseDownOrTouchStart = function (event) {\n    if (ranged) {\n      var currentSteps = calculateCurrentSteps(event);\n      var newValue = min + step * currentSteps;\n      internalState.isAdjustingLowerValue = newValue <= internalState.latestLowerValue || newValue - internalState.latestLowerValue <= internalState.latestValue - newValue;\n    }\n\n    if (event.type === 'mousedown') {\n      disposables.current.push(on(window, 'mousemove', onMouseMoveOrTouchMove, true), on(window, 'mouseup', onMouseUpOrTouchEnd, true));\n    } else if (event.type === 'touchstart') {\n      disposables.current.push(on(window, 'touchmove', onMouseMoveOrTouchMove, true), on(window, 'touchend', onMouseUpOrTouchEnd, true));\n    }\n\n    onMouseMoveOrTouchMove(event, true);\n  };\n\n  var onMouseUpOrTouchEnd = function (event) {\n    // Done adjusting, so clear this value\n    internalState.isBetweenSteps = undefined;\n    onChanged === null || onChanged === void 0 ? void 0 : onChanged(event, internalState.latestValue, ranged ? [internalState.latestLowerValue, internalState.latestValue] : undefined);\n    disposeListeners();\n  };\n\n  var onThumbFocus = function (event) {\n    internalState.isAdjustingLowerValue = event.target === lowerValueThumbRef.current;\n  };\n\n  var disposeListeners = function () {\n    disposables.current.forEach(function (dispose) {\n      return dispose();\n    });\n    disposables.current = [];\n  };\n\n  var lowerValueThumbRef = React.useRef(null);\n  var thumbRef = React.useRef(null);\n  useComponentRef(props, ranged && !vertical ? lowerValueThumbRef : thumbRef, value, ranged ? [lowerValue, value] : undefined);\n  var getPositionStyles = getSlotStyleFn(vertical ? 'bottom' : getRTL(props.theme) ? 'right' : 'left');\n  var getTrackStyles = getSlotStyleFn(vertical ? 'height' : 'width');\n  var originValue = originFromZero ? 0 : min;\n  var valuePercent = getPercent(value, min, max);\n  var lowerValuePercent = getPercent(lowerValue, min, max);\n  var originPercentOfLine = getPercent(originValue, min, max);\n  var activeSectionWidth = ranged ? valuePercent - lowerValuePercent : Math.abs(originPercentOfLine - valuePercent);\n  var topSectionWidth = Math.min(100 - valuePercent, 100 - originPercentOfLine);\n  var bottomSectionWidth = ranged ? lowerValuePercent : Math.min(valuePercent, originPercentOfLine);\n  var rootProps = {\n    className: classNames.root,\n    ref: ref\n  };\n  var labelProps = {\n    className: classNames.titleLabel,\n    children: label,\n    disabled: disabled,\n    htmlFor: ariaLabel ? undefined : id\n  };\n  var valueLabelProps = showValue ? {\n    className: classNames.valueLabel,\n    children: valueFormat ? valueFormat(value) : value,\n    disabled: disabled\n  } : undefined;\n  var lowerValueLabelProps = ranged && showValue ? {\n    className: classNames.valueLabel,\n    children: valueFormat ? valueFormat(lowerValue) : lowerValue,\n    disabled: disabled\n  } : undefined;\n  var zeroTickProps = originFromZero ? {\n    className: classNames.zeroTick,\n    style: getPositionStyles(originPercentOfLine)\n  } : undefined;\n  var trackActiveProps = {\n    className: css(classNames.lineContainer, classNames.activeSection),\n    style: getTrackStyles(activeSectionWidth)\n  };\n  var trackTopInactiveProps = {\n    className: css(classNames.lineContainer, classNames.inactiveSection),\n    style: getTrackStyles(topSectionWidth)\n  };\n  var trackBottomInactiveProps = {\n    className: css(classNames.lineContainer, classNames.inactiveSection),\n    style: getTrackStyles(bottomSectionWidth)\n  };\n\n  var sliderProps = __assign({\n    'aria-disabled': disabled,\n    role: 'slider',\n    tabIndex: disabled ? undefined : 0\n  }, {\n    'data-is-focusable': !disabled\n  });\n\n  var sliderBoxProps = __assign(__assign(__assign({\n    id: id,\n    className: css(classNames.slideBox, buttonProps.className)\n  }, !disabled && {\n    onMouseDown: onMouseDownOrTouchStart,\n    onTouchStart: onMouseDownOrTouchStart,\n    onKeyDown: onKeyDown\n  }), buttonProps && getNativeProps(buttonProps, divProperties, ['id', 'className'])), !ranged && __assign(__assign({}, sliderProps), {\n    'aria-valuemin': min,\n    'aria-valuemax': max,\n    'aria-valuenow': value,\n    'aria-valuetext': getAriaValueText(value),\n    'aria-label': ariaLabel || label\n  }));\n\n  var onFocusProp = disabled ? {} : {\n    onFocus: onThumbFocus\n  };\n\n  var thumbProps = __assign({\n    ref: thumbRef,\n    className: classNames.thumb,\n    style: getPositionStyles(valuePercent)\n  }, ranged && __assign(__assign(__assign({}, sliderProps), onFocusProp), {\n    id: \"max-\" + id,\n    'aria-valuemin': lowerValue,\n    'aria-valuemax': max,\n    'aria-valuenow': value,\n    'aria-valuetext': getAriaValueText(value),\n    'aria-label': \"max \" + (ariaLabel || label)\n  }));\n\n  var lowerValueThumbProps = ranged ? __assign(__assign(__assign({\n    ref: lowerValueThumbRef,\n    className: classNames.thumb,\n    style: getPositionStyles(lowerValuePercent)\n  }, sliderProps), onFocusProp), {\n    id: \"min-\" + id,\n    'aria-valuemin': min,\n    'aria-valuemax': value,\n    'aria-valuenow': lowerValue,\n    'aria-valuetext': getAriaValueText(lowerValue),\n    'aria-label': \"min \" + (ariaLabel || label)\n  }) : undefined;\n  var containerProps = {\n    className: classNames.container\n  };\n  var sliderLineProps = {\n    ref: sliderLine,\n    className: classNames.line\n  };\n  return {\n    root: rootProps,\n    label: labelProps,\n    sliderBox: sliderBoxProps,\n    container: containerProps,\n    valueLabel: valueLabelProps,\n    lowerValueLabel: lowerValueLabelProps,\n    thumb: thumbProps,\n    lowerValueThumb: lowerValueThumbProps,\n    zeroTick: zeroTickProps,\n    activeTrack: trackActiveProps,\n    topInactiveTrack: trackTopInactiveProps,\n    bottomInactiveTrack: trackBottomInactiveProps,\n    sliderLine: sliderLineProps\n  };\n};","map":{"version":3,"sources":["components/Slider/useSlider.ts"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { ISliderProps, ISliderStyleProps, ISliderStyles } from './Slider.types';\nimport { useId, useControllableValue, useConst, useSetTimeout } from '@fluentui/react-hooks';\nimport {\n  KeyCodes,\n  css,\n  getRTL,\n  getRTLSafeKeyCode,\n  on,\n  classNamesFunction,\n  getNativeProps,\n  divProperties,\n} from '@fluentui/utilities';\nimport { ILabelProps } from '../Label/index';\n\nexport const ONKEYDOWN_TIMEOUT_DURATION = 1000;\n\ninterface ISliderInternalState {\n  onKeyDownTimer: number;\n  /** For a ranged slider, whether the thumb currently being dragged is the lower value one. */\n  isAdjustingLowerValue: boolean;\n  /** Allows access to the latest `value` inside reused callbacks (to avoid stale capture issues) */\n  latestValue: number;\n  /** Allows access to the latest `lowerValue` inside reused callbacks (to avoid stale capture issues) */\n  latestLowerValue: number;\n  /**\n   * Whether the user is currently dragging the thumb and it's between step intervals.\n   * (If true, and `props.snapToStep` is falsy, transition animations will be disabled.)\n   */\n  isBetweenSteps?: boolean;\n}\n\nconst getClassNames = classNamesFunction<ISliderStyleProps, ISliderStyles>();\n\ntype Dimension = 'height' | 'width';\ntype Position = 'bottom' | 'left' | 'right';\ntype PositionOrDimension = Dimension | Position;\n/** All the possible event types for a change event */\ntype ChangeEvent = Parameters<Required<ISliderProps>['onChange']>[2];\n/** All the possible event types for a change event that's dragging the slider (mouse or touch) */\ntype DragChangeEvent = React.MouseEvent | React.TouchEvent | MouseEvent | TouchEvent;\n\nconst getSlotStyleFn = (sty: PositionOrDimension) => {\n  return (value: number) => {\n    return {\n      [sty]: `${value}%`,\n    };\n  };\n};\n\nconst getPercent = (value: number, sliderMin: number, sliderMax: number) => {\n  return sliderMax === sliderMin ? 0 : ((value - sliderMin) / (sliderMax - sliderMin)) * 100;\n};\n\nconst useComponentRef = (\n  props: ISliderProps,\n  thumb: React.RefObject<HTMLSpanElement>,\n  value: number | undefined,\n  range: [number, number] | undefined,\n) => {\n  React.useImperativeHandle(\n    props.componentRef,\n    () => ({\n      get value() {\n        return value;\n      },\n      get range() {\n        return range;\n      },\n      focus() {\n        if (thumb.current) {\n          thumb.current.focus();\n        }\n      },\n    }),\n    [thumb, value, range],\n  );\n};\n\nexport const useSlider = (props: ISliderProps, ref: React.Ref<HTMLDivElement>) => {\n  const {\n    step = 1,\n    className,\n    disabled = false,\n    label,\n    max = 10,\n    min = 0,\n    showValue = true,\n    buttonProps = {},\n    vertical = false,\n    snapToStep,\n    valueFormat,\n    styles,\n    theme,\n    originFromZero,\n    'aria-label': ariaLabel,\n    ranged,\n    onChange,\n    onChanged,\n  } = props;\n\n  const disposables = React.useRef<(() => void)[]>([]);\n  const { setTimeout, clearTimeout } = useSetTimeout();\n  const sliderLine = React.useRef<HTMLDivElement>(null);\n\n  // Casting here is necessary because useControllableValue expects the event for the change callback\n  // to extend React.SyntheticEvent, when in fact for Slider, the event could be either a React event\n  // or a native browser event depending on the context.\n  const [unclampedValue, setValue] = useControllableValue(props.value, props.defaultValue, (ev: any, v) =>\n    onChange?.(v!, ranged ? [internalState.latestLowerValue, v!] : undefined, ev),\n  ) as [number | undefined, (v: number | undefined, ev: ChangeEvent) => void];\n  const [unclampedLowerValue, setLowerValue] = useControllableValue(\n    props.lowerValue,\n    props.defaultLowerValue,\n    (ev: any, lv) => onChange?.(internalState.latestValue, [lv!, internalState.latestValue], ev),\n  ) as [number | undefined, (v: number | undefined, ev: ChangeEvent) => void];\n\n  // Ensure that value is always a number and is clamped by min/max.\n  const value = Math.max(min, Math.min(max, unclampedValue || 0));\n  const lowerValue = Math.max(min, Math.min(value, unclampedLowerValue || 0));\n\n  const internalState = useConst<ISliderInternalState>({\n    onKeyDownTimer: -1,\n    isAdjustingLowerValue: false,\n    latestValue: value,\n    latestLowerValue: lowerValue,\n  });\n  // On each render, update this saved value used by callbacks. (This should be safe even if render\n  // is called multiple times, because an event handler or timeout callback will only run once.)\n  internalState.latestValue = value;\n  internalState.latestLowerValue = lowerValue;\n\n  const id = useId('Slider', props.id || buttonProps?.id);\n  const classNames = getClassNames(styles, {\n    className,\n    disabled,\n    vertical,\n    showTransitions: !snapToStep && !internalState.isBetweenSteps,\n    showValue,\n    ranged,\n    theme: theme!,\n  });\n\n  const steps = (max - min) / step;\n\n  const clearOnKeyDownTimer = (): void => {\n    clearTimeout(internalState.onKeyDownTimer);\n    internalState.onKeyDownTimer = -1;\n  };\n\n  const setOnKeyDownTimer = (event: React.KeyboardEvent) => {\n    clearOnKeyDownTimer();\n    if (onChanged) {\n      internalState.onKeyDownTimer = setTimeout(() => {\n        onChanged(\n          event,\n          internalState.latestValue,\n          ranged ? [internalState.latestLowerValue, internalState.latestValue] : undefined,\n        );\n      }, ONKEYDOWN_TIMEOUT_DURATION);\n    }\n  };\n\n  const getAriaValueText = (valueProps: number | undefined): string | undefined => {\n    const { ariaValueText } = props;\n    if (valueProps !== undefined) {\n      return ariaValueText ? ariaValueText(valueProps) : valueProps.toString();\n    }\n    return undefined;\n  };\n\n  /**\n   * Update `value` or `lowerValue`, including clamping between min/max and rounding to\n   * appropriate precision.\n   * @param newValue - New current value of the slider, possibly rounded to a whole step.\n   * @param newUnroundedValue - Like `newValue` but without the rounding to a step. If this is\n   * provided and not equal to `newValue`, `internalState.isBetweenSteps` will be set, which\n   * may cause thumb movement animations to be disabled.\n   */\n  const updateValue = (ev: any, newValue: number, newUnroundedValue?: number): void => {\n    newValue = Math.min(max, Math.max(min, newValue));\n    newUnroundedValue = newUnroundedValue !== undefined ? Math.min(max, Math.max(min, newUnroundedValue)) : undefined;\n\n    let numDec = 0;\n    if (isFinite(step)) {\n      while (Math.round(step * Math.pow(10, numDec)) / Math.pow(10, numDec) !== step) {\n        numDec++;\n      }\n    }\n    // Make sure value has correct number of decimal places based on number of decimals in step\n    const roundedValue = parseFloat(newValue.toFixed(numDec));\n\n    internalState.isBetweenSteps = newUnroundedValue !== undefined && newUnroundedValue !== roundedValue;\n\n    if (ranged) {\n      // decided which thumb value to change\n      if (\n        internalState.isAdjustingLowerValue &&\n        (originFromZero ? roundedValue <= 0 : roundedValue <= internalState.latestValue)\n      ) {\n        setLowerValue(roundedValue, ev);\n      } else if (\n        !internalState.isAdjustingLowerValue &&\n        (originFromZero ? roundedValue >= 0 : roundedValue >= internalState.latestLowerValue)\n      ) {\n        setValue(roundedValue, ev);\n      }\n    } else {\n      setValue(roundedValue, ev);\n    }\n  };\n\n  const onKeyDown = (event: React.KeyboardEvent): void => {\n    let newCurrentValue = internalState.isAdjustingLowerValue\n      ? internalState.latestLowerValue\n      : internalState.latestValue;\n    let diff = 0;\n    // eslint-disable-next-line deprecation/deprecation\n    switch (event.which) {\n      case getRTLSafeKeyCode(KeyCodes.left, props.theme):\n      case KeyCodes.down:\n        diff = -step;\n        clearOnKeyDownTimer();\n        setOnKeyDownTimer(event);\n        break;\n      case getRTLSafeKeyCode(KeyCodes.right, props.theme):\n      case KeyCodes.up:\n        diff = step;\n        clearOnKeyDownTimer();\n        setOnKeyDownTimer(event);\n        break;\n      case KeyCodes.home:\n        newCurrentValue = min;\n        clearOnKeyDownTimer();\n        setOnKeyDownTimer(event);\n        break;\n      case KeyCodes.end:\n        newCurrentValue = max;\n        clearOnKeyDownTimer();\n        setOnKeyDownTimer(event);\n        break;\n      default:\n        return;\n    }\n    updateValue(event, newCurrentValue + diff);\n    event.preventDefault();\n    event.stopPropagation();\n  };\n\n  const getPosition = (event: DragChangeEvent, verticalProp: boolean | undefined): number => {\n    let currentPosition = 0;\n    switch (event.type) {\n      case 'mousedown':\n      case 'mousemove':\n        currentPosition = !verticalProp ? (event as MouseEvent).clientX : (event as MouseEvent).clientY;\n        break;\n      case 'touchstart':\n      case 'touchmove':\n        currentPosition = !verticalProp\n          ? (event as TouchEvent).touches[0].clientX\n          : (event as TouchEvent).touches[0].clientY;\n        break;\n    }\n    return currentPosition;\n  };\n\n  const calculateCurrentSteps = (event: DragChangeEvent) => {\n    const sliderPositionRect: ClientRect = sliderLine.current!.getBoundingClientRect();\n    const sliderLength: number = !props.vertical ? sliderPositionRect.width : sliderPositionRect.height;\n    const stepLength: number = sliderLength / steps;\n    let currentSteps: number;\n    let distance: number;\n    if (!props.vertical) {\n      const left = getPosition(event, props.vertical);\n      distance = getRTL(props.theme) ? sliderPositionRect.right - left : left - sliderPositionRect.left;\n      currentSteps = distance / stepLength;\n    } else {\n      const bottom = getPosition(event, props.vertical);\n      distance = sliderPositionRect.bottom - bottom;\n      currentSteps = distance / stepLength;\n    }\n    return currentSteps;\n  };\n\n  const onMouseMoveOrTouchMove = (event: DragChangeEvent, suppressEventCancelation?: boolean): void => {\n    const currentSteps = calculateCurrentSteps(event);\n    const newUnroundedValue = min + step * currentSteps;\n    const newCurrentValue = min + step * Math.round(currentSteps);\n    updateValue(event, newCurrentValue, newUnroundedValue);\n    if (!suppressEventCancelation) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n  };\n\n  const onMouseDownOrTouchStart = (event: React.MouseEvent | React.TouchEvent): void => {\n    if (ranged) {\n      const currentSteps = calculateCurrentSteps(event);\n      const newValue = min + step * currentSteps;\n\n      internalState.isAdjustingLowerValue =\n        newValue <= internalState.latestLowerValue ||\n        newValue - internalState.latestLowerValue <= internalState.latestValue - newValue;\n    }\n\n    if (event.type === 'mousedown') {\n      disposables.current.push(\n        on(window, 'mousemove', onMouseMoveOrTouchMove as (ev: Event) => void, true),\n        on(window, 'mouseup', onMouseUpOrTouchEnd, true),\n      );\n    } else if (event.type === 'touchstart') {\n      disposables.current.push(\n        on(window, 'touchmove', onMouseMoveOrTouchMove as (ev: Event) => void, true),\n        on(window, 'touchend', onMouseUpOrTouchEnd, true),\n      );\n    }\n    onMouseMoveOrTouchMove(event, true);\n  };\n\n  const onMouseUpOrTouchEnd = (event: MouseEvent | TouchEvent): void => {\n    // Done adjusting, so clear this value\n    internalState.isBetweenSteps = undefined;\n\n    onChanged?.(\n      event,\n      internalState.latestValue,\n      ranged ? [internalState.latestLowerValue, internalState.latestValue] : undefined,\n    );\n    disposeListeners();\n  };\n\n  const onThumbFocus = (event: React.FocusEvent): void => {\n    internalState.isAdjustingLowerValue = event.target === lowerValueThumbRef.current;\n  };\n\n  const disposeListeners = (): void => {\n    disposables.current.forEach(dispose => dispose());\n    disposables.current = [];\n  };\n\n  const lowerValueThumbRef = React.useRef<HTMLElement>(null);\n  const thumbRef = React.useRef<HTMLElement>(null);\n  useComponentRef(\n    props,\n    ranged && !vertical ? lowerValueThumbRef : thumbRef,\n    value,\n    ranged ? [lowerValue, value] : undefined,\n  );\n  const getPositionStyles = getSlotStyleFn(vertical ? 'bottom' : getRTL(props.theme) ? 'right' : 'left');\n  const getTrackStyles = getSlotStyleFn(vertical ? 'height' : 'width');\n  const originValue = originFromZero ? 0 : min;\n  const valuePercent = getPercent(value, min, max);\n  const lowerValuePercent = getPercent(lowerValue, min, max);\n  const originPercentOfLine = getPercent(originValue, min, max);\n  const activeSectionWidth = ranged ? valuePercent - lowerValuePercent : Math.abs(originPercentOfLine - valuePercent);\n  const topSectionWidth = Math.min(100 - valuePercent, 100 - originPercentOfLine);\n  const bottomSectionWidth = ranged ? lowerValuePercent : Math.min(valuePercent, originPercentOfLine);\n\n  const rootProps: React.HTMLAttributes<HTMLDivElement> & React.RefAttributes<HTMLDivElement> = {\n    className: classNames.root,\n    ref: ref,\n  };\n\n  const labelProps: ILabelProps = {\n    className: classNames.titleLabel,\n    children: label,\n    disabled,\n    htmlFor: ariaLabel ? undefined : id,\n  };\n\n  const valueLabelProps: ILabelProps | undefined = showValue\n    ? {\n        className: classNames.valueLabel,\n        children: valueFormat ? valueFormat(value) : value,\n        disabled,\n      }\n    : undefined;\n\n  const lowerValueLabelProps: ILabelProps | undefined =\n    ranged && showValue\n      ? {\n          className: classNames.valueLabel,\n          children: valueFormat ? valueFormat(lowerValue) : lowerValue,\n          disabled,\n        }\n      : undefined;\n\n  const zeroTickProps: React.HTMLAttributes<HTMLElement> | undefined = originFromZero\n    ? {\n        className: classNames.zeroTick,\n        style: getPositionStyles(originPercentOfLine),\n      }\n    : undefined;\n\n  const trackActiveProps: React.HTMLAttributes<HTMLElement> = {\n    className: css(classNames.lineContainer, classNames.activeSection),\n    style: getTrackStyles(activeSectionWidth),\n  };\n\n  const trackTopInactiveProps: React.HTMLAttributes<HTMLElement> = {\n    className: css(classNames.lineContainer, classNames.inactiveSection),\n    style: getTrackStyles(topSectionWidth),\n  };\n\n  const trackBottomInactiveProps: React.HTMLAttributes<HTMLElement> = {\n    className: css(classNames.lineContainer, classNames.inactiveSection),\n    style: getTrackStyles(bottomSectionWidth),\n  };\n\n  const sliderProps: React.HTMLAttributes<HTMLElement> = {\n    'aria-disabled': disabled,\n    role: 'slider',\n    tabIndex: disabled ? undefined : 0,\n    ...({ 'data-is-focusable': !disabled } as any),\n  };\n\n  const sliderBoxProps: React.HTMLAttributes<HTMLElement> = {\n    id,\n    className: css(classNames.slideBox, buttonProps.className),\n    ...(!disabled && {\n      onMouseDown: onMouseDownOrTouchStart,\n      onTouchStart: onMouseDownOrTouchStart,\n      onKeyDown: onKeyDown,\n    }),\n    ...(buttonProps &&\n      getNativeProps<React.HTMLAttributes<HTMLDivElement>>(buttonProps, divProperties, ['id', 'className'])),\n    ...(!ranged && {\n      ...sliderProps,\n      'aria-valuemin': min,\n      'aria-valuemax': max,\n      'aria-valuenow': value,\n      'aria-valuetext': getAriaValueText(value),\n      'aria-label': ariaLabel || label,\n    }),\n  };\n\n  const onFocusProp = disabled ? {} : { onFocus: onThumbFocus };\n\n  const thumbProps: React.HTMLAttributes<HTMLElement> & React.RefAttributes<HTMLElement> = {\n    ref: thumbRef,\n    className: classNames.thumb,\n    style: getPositionStyles(valuePercent),\n    ...(ranged && {\n      ...sliderProps,\n      ...onFocusProp,\n      id: `max-${id}`,\n      'aria-valuemin': lowerValue,\n      'aria-valuemax': max,\n      'aria-valuenow': value,\n      'aria-valuetext': getAriaValueText(value),\n      'aria-label': `max ${ariaLabel || label}`,\n    }),\n  };\n\n  const lowerValueThumbProps:\n    | (React.HTMLAttributes<HTMLElement> & React.RefAttributes<HTMLElement>)\n    | undefined = ranged\n    ? {\n        ref: lowerValueThumbRef,\n        className: classNames.thumb,\n        style: getPositionStyles(lowerValuePercent),\n        ...sliderProps,\n        ...onFocusProp,\n        id: `min-${id}`,\n        'aria-valuemin': min,\n        'aria-valuemax': value,\n        'aria-valuenow': lowerValue,\n        'aria-valuetext': getAriaValueText(lowerValue),\n        'aria-label': `min ${ariaLabel || label}`,\n      }\n    : undefined;\n\n  const containerProps: React.HTMLAttributes<HTMLElement> = {\n    className: classNames.container,\n  };\n\n  const sliderLineProps: React.HTMLAttributes<HTMLDivElement> & React.RefAttributes<HTMLDivElement> = {\n    ref: sliderLine,\n    className: classNames.line,\n  };\n\n  return {\n    root: rootProps,\n    label: labelProps,\n    sliderBox: sliderBoxProps,\n    container: containerProps,\n    valueLabel: valueLabelProps,\n    lowerValueLabel: lowerValueLabelProps,\n    thumb: thumbProps,\n    lowerValueThumb: lowerValueThumbProps,\n    zeroTick: zeroTickProps,\n    activeTrack: trackActiveProps,\n    topInactiveTrack: trackTopInactiveProps,\n    bottomInactiveTrack: trackBottomInactiveProps,\n    sliderLine: sliderLineProps,\n  };\n};\n"],"sourceRoot":"../src/"},"metadata":{},"sourceType":"module"}