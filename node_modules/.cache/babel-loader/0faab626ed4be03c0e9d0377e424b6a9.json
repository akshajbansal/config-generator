{"ast":null,"code":"function _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport toPath from \"lodash/toPath\";\nimport Ajv from \"ajv\";\nvar ajv = createAjvInstance();\nimport { deepEquals, getDefaultFormState } from \"./utils\";\nvar formerCustomFormats = null;\nvar formerMetaSchema = null;\nvar ROOT_SCHEMA_PREFIX = \"__rjsf_rootSchema\";\nimport { isObject, mergeObjects } from \"./utils\";\n\nfunction createAjvInstance() {\n  var ajv = new Ajv({\n    errorDataPath: \"property\",\n    allErrors: true,\n    multipleOfPrecision: 8,\n    schemaId: \"auto\",\n    unknownFormats: \"ignore\"\n  }); // add custom formats\n\n  ajv.addFormat(\"data-url\", /^data:([a-z]+\\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/);\n  ajv.addFormat(\"color\", /^(#?([0-9A-Fa-f]{3}){1,2}\\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\\(\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*\\))|(rgb\\(\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*\\)))$/);\n  return ajv;\n}\n\nfunction toErrorSchema(errors) {\n  // Transforms a ajv validation errors list:\n  // [\n  //   {property: \".level1.level2[2].level3\", message: \"err a\"},\n  //   {property: \".level1.level2[2].level3\", message: \"err b\"},\n  //   {property: \".level1.level2[4].level3\", message: \"err b\"},\n  // ]\n  // Into an error tree:\n  // {\n  //   level1: {\n  //     level2: {\n  //       2: {level3: {errors: [\"err a\", \"err b\"]}},\n  //       4: {level3: {errors: [\"err b\"]}},\n  //     }\n  //   }\n  // };\n  if (!errors.length) {\n    return {};\n  }\n\n  return errors.reduce(function (errorSchema, error) {\n    var property = error.property,\n        message = error.message;\n    var path = toPath(property);\n    var parent = errorSchema; // If the property is at the root (.level1) then toPath creates\n    // an empty array element at the first index. Remove it.\n\n    if (path.length > 0 && path[0] === \"\") {\n      path.splice(0, 1);\n    }\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = path.slice(0)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var segment = _step.value;\n\n        if (!(segment in parent)) {\n          parent[segment] = {};\n        }\n\n        parent = parent[segment];\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n          _iterator[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    if (Array.isArray(parent.__errors)) {\n      // We store the list of errors for this node in a property named __errors\n      // to avoid name collision with a possible sub schema field named\n      // \"errors\" (see `validate.createErrorHandler`).\n      parent.__errors = parent.__errors.concat(message);\n    } else {\n      if (message) {\n        parent.__errors = [message];\n      }\n    }\n\n    return errorSchema;\n  }, {});\n}\n\nexport function toErrorList(errorSchema) {\n  var fieldName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"root\"; // XXX: We should transform fieldName as a full field path string.\n\n  var errorList = [];\n\n  if (\"__errors\" in errorSchema) {\n    errorList = errorList.concat(errorSchema.__errors.map(function (stack) {\n      return {\n        stack: \"\".concat(fieldName, \": \").concat(stack)\n      };\n    }));\n  }\n\n  return Object.keys(errorSchema).reduce(function (acc, key) {\n    if (key !== \"__errors\") {\n      acc = acc.concat(toErrorList(errorSchema[key], key));\n    }\n\n    return acc;\n  }, errorList);\n}\n\nfunction createErrorHandler(formData) {\n  var handler = {\n    // We store the list of errors for this node in a property named __errors\n    // to avoid name collision with a possible sub schema field named\n    // \"errors\" (see `utils.toErrorSchema`).\n    __errors: [],\n    addError: function addError(message) {\n      this.__errors.push(message);\n    }\n  };\n\n  if (isObject(formData)) {\n    return Object.keys(formData).reduce(function (acc, key) {\n      return _objectSpread({}, acc, _defineProperty({}, key, createErrorHandler(formData[key])));\n    }, handler);\n  }\n\n  if (Array.isArray(formData)) {\n    return formData.reduce(function (acc, value, key) {\n      return _objectSpread({}, acc, _defineProperty({}, key, createErrorHandler(value)));\n    }, handler);\n  }\n\n  return handler;\n}\n\nfunction unwrapErrorHandler(errorHandler) {\n  return Object.keys(errorHandler).reduce(function (acc, key) {\n    if (key === \"addError\") {\n      return acc;\n    } else if (key === \"__errors\") {\n      return _objectSpread({}, acc, _defineProperty({}, key, errorHandler[key]));\n    }\n\n    return _objectSpread({}, acc, _defineProperty({}, key, unwrapErrorHandler(errorHandler[key])));\n  }, {});\n}\n/**\n * Transforming the error output from ajv to format used by jsonschema.\n * At some point, components should be updated to support ajv.\n */\n\n\nfunction transformAjvErrors() {\n  var errors = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n  if (errors === null) {\n    return [];\n  }\n\n  return errors.map(function (e) {\n    var dataPath = e.dataPath,\n        keyword = e.keyword,\n        message = e.message,\n        params = e.params,\n        schemaPath = e.schemaPath;\n    var property = \"\".concat(dataPath); // put data in expected format\n\n    return {\n      name: keyword,\n      property: property,\n      message: message,\n      params: params,\n      // specific to ajv\n      stack: \"\".concat(property, \" \").concat(message).trim(),\n      schemaPath: schemaPath\n    };\n  });\n}\n/**\n * This function processes the formData with a user `validate` contributed\n * function, which receives the form data and an `errorHandler` object that\n * will be used to add custom validation errors for each field.\n */\n\n\nexport default function validateFormData(formData, schema, customValidate, transformErrors) {\n  var additionalMetaSchemas = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n  var customFormats = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {}; // Include form data with undefined values, which is required for validation.\n\n  var rootSchema = schema;\n  formData = getDefaultFormState(schema, formData, rootSchema, true);\n  var newMetaSchemas = !deepEquals(formerMetaSchema, additionalMetaSchemas);\n  var newFormats = !deepEquals(formerCustomFormats, customFormats);\n\n  if (newMetaSchemas || newFormats) {\n    ajv = createAjvInstance();\n  } // add more schemas to validate against\n\n\n  if (additionalMetaSchemas && newMetaSchemas && Array.isArray(additionalMetaSchemas)) {\n    ajv.addMetaSchema(additionalMetaSchemas);\n    formerMetaSchema = additionalMetaSchemas;\n  } // add more custom formats to validate against\n\n\n  if (customFormats && newFormats && isObject(customFormats)) {\n    Object.keys(customFormats).forEach(function (formatName) {\n      ajv.addFormat(formatName, customFormats[formatName]);\n    });\n    formerCustomFormats = customFormats;\n  }\n\n  var validationError = null;\n\n  try {\n    ajv.validate(schema, formData);\n  } catch (err) {\n    validationError = err;\n  }\n\n  var errors = transformAjvErrors(ajv.errors); // Clear errors to prevent persistent errors, see #1104\n\n  ajv.errors = null;\n  var noProperMetaSchema = validationError && validationError.message && typeof validationError.message === \"string\" && validationError.message.includes(\"no schema with key or ref \");\n\n  if (noProperMetaSchema) {\n    errors = [].concat(_toConsumableArray(errors), [{\n      stack: validationError.message\n    }]);\n  }\n\n  if (typeof transformErrors === \"function\") {\n    errors = transformErrors(errors);\n  }\n\n  var errorSchema = toErrorSchema(errors);\n\n  if (noProperMetaSchema) {\n    errorSchema = _objectSpread({}, errorSchema, {\n      $schema: {\n        __errors: [validationError.message]\n      }\n    });\n  }\n\n  if (typeof customValidate !== \"function\") {\n    return {\n      errors: errors,\n      errorSchema: errorSchema\n    };\n  }\n\n  var errorHandler = customValidate(formData, createErrorHandler(formData));\n  var userErrorSchema = unwrapErrorHandler(errorHandler);\n  var newErrorSchema = mergeObjects(errorSchema, userErrorSchema, true); // XXX: The errors list produced is not fully compliant with the format\n  // exposed by the jsonschema lib, which contains full field paths and other\n  // properties.\n\n  var newErrors = toErrorList(newErrorSchema);\n  return {\n    errors: newErrors,\n    errorSchema: newErrorSchema\n  };\n}\n/**\n * Recursively prefixes all $ref's in a schema with `ROOT_SCHEMA_PREFIX`\n * This is used in isValid to make references to the rootSchema\n */\n\nexport function withIdRefPrefix(schemaNode) {\n  var obj = schemaNode;\n\n  if (schemaNode.constructor === Object) {\n    obj = _objectSpread({}, schemaNode);\n\n    for (var key in obj) {\n      var value = obj[key];\n\n      if (key === \"$ref\" && typeof value === \"string\" && value.startsWith(\"#\")) {\n        obj[key] = ROOT_SCHEMA_PREFIX + value;\n      } else {\n        obj[key] = withIdRefPrefix(value);\n      }\n    }\n  } else if (Array.isArray(schemaNode)) {\n    obj = _toConsumableArray(schemaNode);\n\n    for (var i = 0; i < obj.length; i++) {\n      obj[i] = withIdRefPrefix(obj[i]);\n    }\n  }\n\n  return obj;\n}\n/**\n * Validates data against a schema, returning true if the data is valid, or\n * false otherwise. If the schema is invalid, then this function will return\n * false.\n */\n\nexport function isValid(schema, data, rootSchema) {\n  try {\n    // add the rootSchema ROOT_SCHEMA_PREFIX as id.\n    // then rewrite the schema ref's to point to the rootSchema\n    // this accounts for the case where schema have references to models\n    // that lives in the rootSchema but not in the schema in question.\n    return ajv.addSchema(rootSchema, ROOT_SCHEMA_PREFIX).validate(withIdRefPrefix(schema), data);\n  } catch (e) {\n    return false;\n  } finally {\n    // make sure we remove the rootSchema from the global ajv instance\n    ajv.removeSchema(ROOT_SCHEMA_PREFIX);\n  }\n}","map":{"version":3,"sources":["C:/Users/Akshaj Bansal/json parser/my-app/node_modules/@rjsf/core/dist/es/validate.js"],"names":["_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","Object","prototype","toString","call","Array","from","isArray","i","arr2","length","_objectSpread","target","arguments","source","ownKeys","keys","getOwnPropertySymbols","concat","filter","sym","getOwnPropertyDescriptor","enumerable","forEach","key","_defineProperty","obj","value","defineProperty","configurable","writable","toPath","Ajv","ajv","createAjvInstance","deepEquals","getDefaultFormState","formerCustomFormats","formerMetaSchema","ROOT_SCHEMA_PREFIX","isObject","mergeObjects","errorDataPath","allErrors","multipleOfPrecision","schemaId","unknownFormats","addFormat","toErrorSchema","errors","reduce","errorSchema","error","property","message","path","parent","splice","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","slice","_step","next","done","segment","err","__errors","toErrorList","fieldName","errorList","map","stack","acc","createErrorHandler","formData","handler","addError","push","unwrapErrorHandler","errorHandler","transformAjvErrors","e","dataPath","keyword","params","schemaPath","name","trim","validateFormData","schema","customValidate","transformErrors","additionalMetaSchemas","customFormats","rootSchema","newMetaSchemas","newFormats","addMetaSchema","formatName","validationError","validate","noProperMetaSchema","includes","$schema","userErrorSchema","newErrorSchema","newErrors","withIdRefPrefix","schemaNode","constructor","startsWith","isValid","data","addSchema","removeSchema"],"mappings":"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","sourcesContent":["function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport toPath from \"lodash/toPath\";\nimport Ajv from \"ajv\";\nvar ajv = createAjvInstance();\nimport { deepEquals, getDefaultFormState } from \"./utils\";\nvar formerCustomFormats = null;\nvar formerMetaSchema = null;\nvar ROOT_SCHEMA_PREFIX = \"__rjsf_rootSchema\";\nimport { isObject, mergeObjects } from \"./utils\";\n\nfunction createAjvInstance() {\n  var ajv = new Ajv({\n    errorDataPath: \"property\",\n    allErrors: true,\n    multipleOfPrecision: 8,\n    schemaId: \"auto\",\n    unknownFormats: \"ignore\"\n  }); // add custom formats\n\n  ajv.addFormat(\"data-url\", /^data:([a-z]+\\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/);\n  ajv.addFormat(\"color\", /^(#?([0-9A-Fa-f]{3}){1,2}\\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgb\\(\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*\\b([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\b\\s*\\))|(rgb\\(\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*,\\s*(\\d?\\d%|100%)+\\s*\\)))$/);\n  return ajv;\n}\n\nfunction toErrorSchema(errors) {\n  // Transforms a ajv validation errors list:\n  // [\n  //   {property: \".level1.level2[2].level3\", message: \"err a\"},\n  //   {property: \".level1.level2[2].level3\", message: \"err b\"},\n  //   {property: \".level1.level2[4].level3\", message: \"err b\"},\n  // ]\n  // Into an error tree:\n  // {\n  //   level1: {\n  //     level2: {\n  //       2: {level3: {errors: [\"err a\", \"err b\"]}},\n  //       4: {level3: {errors: [\"err b\"]}},\n  //     }\n  //   }\n  // };\n  if (!errors.length) {\n    return {};\n  }\n\n  return errors.reduce(function (errorSchema, error) {\n    var property = error.property,\n        message = error.message;\n    var path = toPath(property);\n    var parent = errorSchema; // If the property is at the root (.level1) then toPath creates\n    // an empty array element at the first index. Remove it.\n\n    if (path.length > 0 && path[0] === \"\") {\n      path.splice(0, 1);\n    }\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = path.slice(0)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var segment = _step.value;\n\n        if (!(segment in parent)) {\n          parent[segment] = {};\n        }\n\n        parent = parent[segment];\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n          _iterator[\"return\"]();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    if (Array.isArray(parent.__errors)) {\n      // We store the list of errors for this node in a property named __errors\n      // to avoid name collision with a possible sub schema field named\n      // \"errors\" (see `validate.createErrorHandler`).\n      parent.__errors = parent.__errors.concat(message);\n    } else {\n      if (message) {\n        parent.__errors = [message];\n      }\n    }\n\n    return errorSchema;\n  }, {});\n}\n\nexport function toErrorList(errorSchema) {\n  var fieldName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"root\";\n  // XXX: We should transform fieldName as a full field path string.\n  var errorList = [];\n\n  if (\"__errors\" in errorSchema) {\n    errorList = errorList.concat(errorSchema.__errors.map(function (stack) {\n      return {\n        stack: \"\".concat(fieldName, \": \").concat(stack)\n      };\n    }));\n  }\n\n  return Object.keys(errorSchema).reduce(function (acc, key) {\n    if (key !== \"__errors\") {\n      acc = acc.concat(toErrorList(errorSchema[key], key));\n    }\n\n    return acc;\n  }, errorList);\n}\n\nfunction createErrorHandler(formData) {\n  var handler = {\n    // We store the list of errors for this node in a property named __errors\n    // to avoid name collision with a possible sub schema field named\n    // \"errors\" (see `utils.toErrorSchema`).\n    __errors: [],\n    addError: function addError(message) {\n      this.__errors.push(message);\n    }\n  };\n\n  if (isObject(formData)) {\n    return Object.keys(formData).reduce(function (acc, key) {\n      return _objectSpread({}, acc, _defineProperty({}, key, createErrorHandler(formData[key])));\n    }, handler);\n  }\n\n  if (Array.isArray(formData)) {\n    return formData.reduce(function (acc, value, key) {\n      return _objectSpread({}, acc, _defineProperty({}, key, createErrorHandler(value)));\n    }, handler);\n  }\n\n  return handler;\n}\n\nfunction unwrapErrorHandler(errorHandler) {\n  return Object.keys(errorHandler).reduce(function (acc, key) {\n    if (key === \"addError\") {\n      return acc;\n    } else if (key === \"__errors\") {\n      return _objectSpread({}, acc, _defineProperty({}, key, errorHandler[key]));\n    }\n\n    return _objectSpread({}, acc, _defineProperty({}, key, unwrapErrorHandler(errorHandler[key])));\n  }, {});\n}\n/**\n * Transforming the error output from ajv to format used by jsonschema.\n * At some point, components should be updated to support ajv.\n */\n\n\nfunction transformAjvErrors() {\n  var errors = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n  if (errors === null) {\n    return [];\n  }\n\n  return errors.map(function (e) {\n    var dataPath = e.dataPath,\n        keyword = e.keyword,\n        message = e.message,\n        params = e.params,\n        schemaPath = e.schemaPath;\n    var property = \"\".concat(dataPath); // put data in expected format\n\n    return {\n      name: keyword,\n      property: property,\n      message: message,\n      params: params,\n      // specific to ajv\n      stack: \"\".concat(property, \" \").concat(message).trim(),\n      schemaPath: schemaPath\n    };\n  });\n}\n/**\n * This function processes the formData with a user `validate` contributed\n * function, which receives the form data and an `errorHandler` object that\n * will be used to add custom validation errors for each field.\n */\n\n\nexport default function validateFormData(formData, schema, customValidate, transformErrors) {\n  var additionalMetaSchemas = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n  var customFormats = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};\n  // Include form data with undefined values, which is required for validation.\n  var rootSchema = schema;\n  formData = getDefaultFormState(schema, formData, rootSchema, true);\n  var newMetaSchemas = !deepEquals(formerMetaSchema, additionalMetaSchemas);\n  var newFormats = !deepEquals(formerCustomFormats, customFormats);\n\n  if (newMetaSchemas || newFormats) {\n    ajv = createAjvInstance();\n  } // add more schemas to validate against\n\n\n  if (additionalMetaSchemas && newMetaSchemas && Array.isArray(additionalMetaSchemas)) {\n    ajv.addMetaSchema(additionalMetaSchemas);\n    formerMetaSchema = additionalMetaSchemas;\n  } // add more custom formats to validate against\n\n\n  if (customFormats && newFormats && isObject(customFormats)) {\n    Object.keys(customFormats).forEach(function (formatName) {\n      ajv.addFormat(formatName, customFormats[formatName]);\n    });\n    formerCustomFormats = customFormats;\n  }\n\n  var validationError = null;\n\n  try {\n    ajv.validate(schema, formData);\n  } catch (err) {\n    validationError = err;\n  }\n\n  var errors = transformAjvErrors(ajv.errors); // Clear errors to prevent persistent errors, see #1104\n\n  ajv.errors = null;\n  var noProperMetaSchema = validationError && validationError.message && typeof validationError.message === \"string\" && validationError.message.includes(\"no schema with key or ref \");\n\n  if (noProperMetaSchema) {\n    errors = [].concat(_toConsumableArray(errors), [{\n      stack: validationError.message\n    }]);\n  }\n\n  if (typeof transformErrors === \"function\") {\n    errors = transformErrors(errors);\n  }\n\n  var errorSchema = toErrorSchema(errors);\n\n  if (noProperMetaSchema) {\n    errorSchema = _objectSpread({}, errorSchema, {\n      $schema: {\n        __errors: [validationError.message]\n      }\n    });\n  }\n\n  if (typeof customValidate !== \"function\") {\n    return {\n      errors: errors,\n      errorSchema: errorSchema\n    };\n  }\n\n  var errorHandler = customValidate(formData, createErrorHandler(formData));\n  var userErrorSchema = unwrapErrorHandler(errorHandler);\n  var newErrorSchema = mergeObjects(errorSchema, userErrorSchema, true); // XXX: The errors list produced is not fully compliant with the format\n  // exposed by the jsonschema lib, which contains full field paths and other\n  // properties.\n\n  var newErrors = toErrorList(newErrorSchema);\n  return {\n    errors: newErrors,\n    errorSchema: newErrorSchema\n  };\n}\n/**\n * Recursively prefixes all $ref's in a schema with `ROOT_SCHEMA_PREFIX`\n * This is used in isValid to make references to the rootSchema\n */\n\nexport function withIdRefPrefix(schemaNode) {\n  var obj = schemaNode;\n\n  if (schemaNode.constructor === Object) {\n    obj = _objectSpread({}, schemaNode);\n\n    for (var key in obj) {\n      var value = obj[key];\n\n      if (key === \"$ref\" && typeof value === \"string\" && value.startsWith(\"#\")) {\n        obj[key] = ROOT_SCHEMA_PREFIX + value;\n      } else {\n        obj[key] = withIdRefPrefix(value);\n      }\n    }\n  } else if (Array.isArray(schemaNode)) {\n    obj = _toConsumableArray(schemaNode);\n\n    for (var i = 0; i < obj.length; i++) {\n      obj[i] = withIdRefPrefix(obj[i]);\n    }\n  }\n\n  return obj;\n}\n/**\n * Validates data against a schema, returning true if the data is valid, or\n * false otherwise. If the schema is invalid, then this function will return\n * false.\n */\n\nexport function isValid(schema, data, rootSchema) {\n  try {\n    // add the rootSchema ROOT_SCHEMA_PREFIX as id.\n    // then rewrite the schema ref's to point to the rootSchema\n    // this accounts for the case where schema have references to models\n    // that lives in the rootSchema but not in the schema in question.\n    return ajv.addSchema(rootSchema, ROOT_SCHEMA_PREFIX).validate(withIdRefPrefix(schema), data);\n  } catch (e) {\n    return false;\n  } finally {\n    // make sure we remove the rootSchema from the global ajv instance\n    ajv.removeSchema(ROOT_SCHEMA_PREFIX);\n  }\n}"]},"metadata":{},"sourceType":"module"}