{"ast":null,"code":"function _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\n\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n\n  return (hint === \"string\" ? String : Number)(input);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  }\n}\n\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nimport React from \"react\";\nimport * as ReactIs from \"react-is\";\nimport mergeAllOf from \"json-schema-merge-allof\";\nimport fill from \"core-js-pure/features/array/fill\";\nimport union from \"lodash/union\";\nimport jsonpointer from \"jsonpointer\";\nimport fields from \"./components/fields\";\nimport widgets from \"./components/widgets\";\nimport validateFormData, { isValid } from \"./validate\";\nexport var ADDITIONAL_PROPERTY_FLAG = \"__additional_property\";\nvar widgetMap = {\n  \"boolean\": {\n    checkbox: \"CheckboxWidget\",\n    radio: \"RadioWidget\",\n    select: \"SelectWidget\",\n    hidden: \"HiddenWidget\"\n  },\n  string: {\n    text: \"TextWidget\",\n    password: \"PasswordWidget\",\n    email: \"EmailWidget\",\n    hostname: \"TextWidget\",\n    ipv4: \"TextWidget\",\n    ipv6: \"TextWidget\",\n    uri: \"URLWidget\",\n    \"data-url\": \"FileWidget\",\n    radio: \"RadioWidget\",\n    select: \"SelectWidget\",\n    textarea: \"TextareaWidget\",\n    hidden: \"HiddenWidget\",\n    date: \"DateWidget\",\n    datetime: \"DateTimeWidget\",\n    \"date-time\": \"DateTimeWidget\",\n    \"alt-date\": \"AltDateWidget\",\n    \"alt-datetime\": \"AltDateTimeWidget\",\n    color: \"ColorWidget\",\n    file: \"FileWidget\"\n  },\n  number: {\n    text: \"TextWidget\",\n    select: \"SelectWidget\",\n    updown: \"UpDownWidget\",\n    range: \"RangeWidget\",\n    radio: \"RadioWidget\",\n    hidden: \"HiddenWidget\"\n  },\n  integer: {\n    text: \"TextWidget\",\n    select: \"SelectWidget\",\n    updown: \"UpDownWidget\",\n    range: \"RangeWidget\",\n    radio: \"RadioWidget\",\n    hidden: \"HiddenWidget\"\n  },\n  array: {\n    select: \"SelectWidget\",\n    checkboxes: \"CheckboxesWidget\",\n    files: \"FileWidget\",\n    hidden: \"HiddenWidget\"\n  }\n};\nexport function canExpand(schema, uiSchema, formData) {\n  if (!schema.additionalProperties) {\n    return false;\n  }\n\n  var _getUiOptions = getUiOptions(uiSchema),\n      expandable = _getUiOptions.expandable;\n\n  if (expandable === false) {\n    return expandable;\n  } // if ui:options.expandable was not explicitly set to false, we can add\n  // another property if we have not exceeded maxProperties yet\n\n\n  if (schema.maxProperties !== undefined) {\n    return Object.keys(formData).length < schema.maxProperties;\n  }\n\n  return true;\n}\nexport function getDefaultRegistry() {\n  return {\n    fields: fields,\n    widgets: widgets,\n    definitions: {},\n    rootSchema: {},\n    formContext: {}\n  };\n}\n/* Gets the type of a given schema. */\n\nexport function getSchemaType(schema) {\n  var type = schema.type;\n\n  if (!type && schema[\"const\"]) {\n    return guessType(schema[\"const\"]);\n  }\n\n  if (!type && schema[\"enum\"]) {\n    return \"string\";\n  }\n\n  if (!type && (schema.properties || schema.additionalProperties)) {\n    return \"object\";\n  }\n\n  if (type instanceof Array && type.length === 2 && type.includes(\"null\")) {\n    return type.find(function (type) {\n      return type !== \"null\";\n    });\n  }\n\n  return type;\n}\nexport function getWidget(schema, widget) {\n  var registeredWidgets = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var type = getSchemaType(schema);\n\n  function mergeOptions(Widget) {\n    // cache return value as property of widget for proper react reconciliation\n    if (!Widget.MergedWidget) {\n      var defaultOptions = Widget.defaultProps && Widget.defaultProps.options || {};\n\n      Widget.MergedWidget = function (_ref) {\n        var _ref$options = _ref.options,\n            options = _ref$options === void 0 ? {} : _ref$options,\n            props = _objectWithoutProperties(_ref, [\"options\"]);\n\n        return React.createElement(Widget, _extends({\n          options: _objectSpread({}, defaultOptions, options)\n        }, props));\n      };\n    }\n\n    return Widget.MergedWidget;\n  }\n\n  if (typeof widget === \"function\" || ReactIs.isForwardRef(React.createElement(widget)) || ReactIs.isMemo(widget)) {\n    return mergeOptions(widget);\n  }\n\n  if (typeof widget !== \"string\") {\n    throw new Error(\"Unsupported widget definition: \".concat(_typeof(widget)));\n  }\n\n  if (registeredWidgets.hasOwnProperty(widget)) {\n    var registeredWidget = registeredWidgets[widget];\n    return getWidget(schema, registeredWidget, registeredWidgets);\n  }\n\n  if (!widgetMap.hasOwnProperty(type)) {\n    throw new Error(\"No widget for type \\\"\".concat(type, \"\\\"\"));\n  }\n\n  if (widgetMap[type].hasOwnProperty(widget)) {\n    var _registeredWidget = registeredWidgets[widgetMap[type][widget]];\n    return getWidget(schema, _registeredWidget, registeredWidgets);\n  }\n\n  throw new Error(\"No widget \\\"\".concat(widget, \"\\\" for type \\\"\").concat(type, \"\\\"\"));\n}\nexport function hasWidget(schema, widget) {\n  var registeredWidgets = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  try {\n    getWidget(schema, widget, registeredWidgets);\n    return true;\n  } catch (e) {\n    if (e.message && (e.message.startsWith(\"No widget\") || e.message.startsWith(\"Unsupported widget\"))) {\n      return false;\n    }\n\n    throw e;\n  }\n}\n\nfunction computeDefaults(_schema, parentDefaults, rootSchema) {\n  var rawFormData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var includeUndefinedValues = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var schema = isObject(_schema) ? _schema : {};\n  var formData = isObject(rawFormData) ? rawFormData : {}; // Compute the defaults recursively: give highest priority to deepest nodes.\n\n  var defaults = parentDefaults;\n\n  if (isObject(defaults) && isObject(schema[\"default\"])) {\n    // For object defaults, only override parent defaults that are defined in\n    // schema.default.\n    defaults = mergeObjects(defaults, schema[\"default\"]);\n  } else if (\"default\" in schema) {\n    // Use schema defaults for this node.\n    defaults = schema[\"default\"];\n  } else if (\"$ref\" in schema) {\n    // Use referenced schema defaults for this node.\n    var refSchema = findSchemaDefinition(schema.$ref, rootSchema);\n    return computeDefaults(refSchema, defaults, rootSchema, formData, includeUndefinedValues);\n  } else if (\"dependencies\" in schema) {\n    var resolvedSchema = resolveDependencies(schema, rootSchema, formData);\n    return computeDefaults(resolvedSchema, defaults, rootSchema, formData, includeUndefinedValues);\n  } else if (isFixedItems(schema)) {\n    defaults = schema.items.map(function (itemSchema, idx) {\n      return computeDefaults(itemSchema, Array.isArray(parentDefaults) ? parentDefaults[idx] : undefined, rootSchema, formData, includeUndefinedValues);\n    });\n  } else if (\"oneOf\" in schema) {\n    schema = schema.oneOf[getMatchingOption(undefined, schema.oneOf, rootSchema)];\n  } else if (\"anyOf\" in schema) {\n    schema = schema.anyOf[getMatchingOption(undefined, schema.anyOf, rootSchema)];\n  } // Not defaults defined for this node, fallback to generic typed ones.\n\n\n  if (typeof defaults === \"undefined\") {\n    defaults = schema[\"default\"];\n  }\n\n  switch (getSchemaType(schema)) {\n    // We need to recur for object schema inner default values.\n    case \"object\":\n      return Object.keys(schema.properties || {}).reduce(function (acc, key) {\n        // Compute the defaults for this node, with the parent defaults we might\n        // have from a previous run: defaults[key].\n        var computedDefault = computeDefaults(schema.properties[key], (defaults || {})[key], rootSchema, (formData || {})[key], includeUndefinedValues);\n\n        if (includeUndefinedValues || computedDefault !== undefined) {\n          acc[key] = computedDefault;\n        }\n\n        return acc;\n      }, {});\n\n    case \"array\":\n      // Inject defaults into existing array defaults\n      if (Array.isArray(defaults)) {\n        defaults = defaults.map(function (item, idx) {\n          return computeDefaults(schema.items[idx] || schema.additionalItems || {}, item, rootSchema);\n        });\n      } // Deeply inject defaults into already existing form data\n\n\n      if (Array.isArray(rawFormData)) {\n        defaults = rawFormData.map(function (item, idx) {\n          return computeDefaults(schema.items, (defaults || {})[idx], rootSchema, item);\n        });\n      }\n\n      if (schema.minItems) {\n        if (!isMultiSelect(schema, rootSchema)) {\n          var defaultsLength = defaults ? defaults.length : 0;\n\n          if (schema.minItems > defaultsLength) {\n            var defaultEntries = defaults || []; // populate the array with the defaults\n\n            var fillerSchema = Array.isArray(schema.items) ? schema.additionalItems : schema.items;\n            var fillerEntries = fill(new Array(schema.minItems - defaultsLength), computeDefaults(fillerSchema, fillerSchema.defaults, rootSchema)); // then fill up the rest with either the item default or empty, up to minItems\n\n            return defaultEntries.concat(fillerEntries);\n          }\n        } else {\n          return defaults ? defaults : [];\n        }\n      }\n\n  }\n\n  return defaults;\n}\n\nexport function getDefaultFormState(_schema, formData) {\n  var rootSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var includeUndefinedValues = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n  if (!isObject(_schema)) {\n    throw new Error(\"Invalid schema: \" + _schema);\n  }\n\n  var schema = retrieveSchema(_schema, rootSchema, formData);\n  var defaults = computeDefaults(schema, _schema[\"default\"], rootSchema, formData, includeUndefinedValues);\n\n  if (typeof formData === \"undefined\") {\n    // No form data? Use schema defaults.\n    return defaults;\n  }\n\n  if (isObject(formData) || Array.isArray(formData)) {\n    return mergeDefaultsWithFormData(defaults, formData);\n  }\n\n  if (formData === 0 || formData === false || formData === \"\") {\n    return formData;\n  }\n\n  return formData || defaults;\n}\n/**\n * When merging defaults and form data, we want to merge in this specific way:\n * - objects are deeply merged\n * - arrays are merged in such a way that:\n *   - when the array is set in form data, only array entries set in form data\n *     are deeply merged; additional entries from the defaults are ignored\n *   - when the array is not set in form data, the default is copied over\n * - scalars are overwritten/set by form data\n */\n\nexport function mergeDefaultsWithFormData(defaults, formData) {\n  if (Array.isArray(formData)) {\n    if (!Array.isArray(defaults)) {\n      defaults = [];\n    }\n\n    return formData.map(function (value, idx) {\n      if (defaults[idx]) {\n        return mergeDefaultsWithFormData(defaults[idx], value);\n      }\n\n      return value;\n    });\n  } else if (isObject(formData)) {\n    var acc = Object.assign({}, defaults); // Prevent mutation of source object.\n\n    return Object.keys(formData).reduce(function (acc, key) {\n      acc[key] = mergeDefaultsWithFormData(defaults ? defaults[key] : {}, formData[key]);\n      return acc;\n    }, acc);\n  } else {\n    return formData;\n  }\n}\nexport function getUiOptions(uiSchema) {\n  // get all passed options from ui:widget, ui:options, and ui:<optionName>\n  return Object.keys(uiSchema).filter(function (key) {\n    return key.indexOf(\"ui:\") === 0;\n  }).reduce(function (options, key) {\n    var value = uiSchema[key];\n\n    if (key === \"ui:widget\" && isObject(value)) {\n      console.warn(\"Setting options via ui:widget object is deprecated, use ui:options instead\");\n      return _objectSpread({}, options, value.options || {}, {\n        widget: value.component\n      });\n    }\n\n    if (key === \"ui:options\" && isObject(value)) {\n      return _objectSpread({}, options, value);\n    }\n\n    return _objectSpread({}, options, _defineProperty({}, key.substring(3), value));\n  }, {});\n}\nexport function getDisplayLabel(schema, uiSchema, rootSchema) {\n  var uiOptions = getUiOptions(uiSchema);\n  var _uiOptions$label = uiOptions.label,\n      displayLabel = _uiOptions$label === void 0 ? true : _uiOptions$label;\n\n  if (schema.type === \"array\") {\n    displayLabel = isMultiSelect(schema, rootSchema) || isFilesArray(schema, uiSchema, rootSchema);\n  }\n\n  if (schema.type === \"object\") {\n    displayLabel = false;\n  }\n\n  if (schema.type === \"boolean\" && !uiSchema[\"ui:widget\"]) {\n    displayLabel = false;\n  }\n\n  if (uiSchema[\"ui:field\"]) {\n    displayLabel = false;\n  }\n\n  return displayLabel;\n}\nexport function isObject(thing) {\n  if (typeof File !== \"undefined\" && thing instanceof File) {\n    return false;\n  }\n\n  return _typeof(thing) === \"object\" && thing !== null && !Array.isArray(thing);\n}\nexport function mergeObjects(obj1, obj2) {\n  var concatArrays = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false; // Recursively merge deeply nested objects.\n\n  var acc = Object.assign({}, obj1); // Prevent mutation of source object.\n\n  return Object.keys(obj2).reduce(function (acc, key) {\n    var left = obj1 ? obj1[key] : {},\n        right = obj2[key];\n\n    if (obj1 && obj1.hasOwnProperty(key) && isObject(right)) {\n      acc[key] = mergeObjects(left, right, concatArrays);\n    } else if (concatArrays && Array.isArray(left) && Array.isArray(right)) {\n      acc[key] = left.concat(right);\n    } else {\n      acc[key] = right;\n    }\n\n    return acc;\n  }, acc);\n}\nexport function asNumber(value) {\n  if (value === \"\") {\n    return undefined;\n  }\n\n  if (value === null) {\n    return null;\n  }\n\n  if (/\\.$/.test(value)) {\n    // \"3.\" can't really be considered a number even if it parses in js. The\n    // user is most likely entering a float.\n    return value;\n  }\n\n  if (/\\.0$/.test(value)) {\n    // we need to return this as a string here, to allow for input like 3.07\n    return value;\n  }\n\n  var n = Number(value);\n  var valid = typeof n === \"number\" && !Number.isNaN(n);\n\n  if (/\\.\\d*0$/.test(value)) {\n    // It's a number, that's cool - but we need it as a string so it doesn't screw\n    // with the user when entering dollar amounts or other values (such as those with\n    // specific precision or number of significant digits)\n    return value;\n  }\n\n  return valid ? n : value;\n}\nexport function orderProperties(properties, order) {\n  if (!Array.isArray(order)) {\n    return properties;\n  }\n\n  var arrayToHash = function arrayToHash(arr) {\n    return arr.reduce(function (prev, curr) {\n      prev[curr] = true;\n      return prev;\n    }, {});\n  };\n\n  var errorPropList = function errorPropList(arr) {\n    return arr.length > 1 ? \"properties '\".concat(arr.join(\"', '\"), \"'\") : \"property '\".concat(arr[0], \"'\");\n  };\n\n  var propertyHash = arrayToHash(properties);\n  var orderFiltered = order.filter(function (prop) {\n    return prop === \"*\" || propertyHash[prop];\n  });\n  var orderHash = arrayToHash(orderFiltered);\n  var rest = properties.filter(function (prop) {\n    return !orderHash[prop];\n  });\n  var restIndex = orderFiltered.indexOf(\"*\");\n\n  if (restIndex === -1) {\n    if (rest.length) {\n      throw new Error(\"uiSchema order list does not contain \".concat(errorPropList(rest)));\n    }\n\n    return orderFiltered;\n  }\n\n  if (restIndex !== orderFiltered.lastIndexOf(\"*\")) {\n    throw new Error(\"uiSchema order list contains more than one wildcard item\");\n  }\n\n  var complete = _toConsumableArray(orderFiltered);\n\n  complete.splice.apply(complete, [restIndex, 1].concat(_toConsumableArray(rest)));\n  return complete;\n}\n/**\n * This function checks if the given schema matches a single\n * constant value.\n */\n\nexport function isConstant(schema) {\n  return Array.isArray(schema[\"enum\"]) && schema[\"enum\"].length === 1 || schema.hasOwnProperty(\"const\");\n}\nexport function toConstant(schema) {\n  if (Array.isArray(schema[\"enum\"]) && schema[\"enum\"].length === 1) {\n    return schema[\"enum\"][0];\n  } else if (schema.hasOwnProperty(\"const\")) {\n    return schema[\"const\"];\n  } else {\n    throw new Error(\"schema cannot be inferred as a constant\");\n  }\n}\nexport function isSelect(_schema) {\n  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var schema = retrieveSchema(_schema, rootSchema);\n  var altSchemas = schema.oneOf || schema.anyOf;\n\n  if (Array.isArray(schema[\"enum\"])) {\n    return true;\n  } else if (Array.isArray(altSchemas)) {\n    return altSchemas.every(function (altSchemas) {\n      return isConstant(altSchemas);\n    });\n  }\n\n  return false;\n}\nexport function isMultiSelect(schema) {\n  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!schema.uniqueItems || !schema.items) {\n    return false;\n  }\n\n  return isSelect(schema.items, rootSchema);\n}\nexport function isFilesArray(schema, uiSchema) {\n  var rootSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (uiSchema[\"ui:widget\"] === \"files\") {\n    return true;\n  } else if (schema.items) {\n    var itemsSchema = retrieveSchema(schema.items, rootSchema);\n    return itemsSchema.type === \"string\" && itemsSchema.format === \"data-url\";\n  }\n\n  return false;\n}\nexport function isFixedItems(schema) {\n  return Array.isArray(schema.items) && schema.items.length > 0 && schema.items.every(function (item) {\n    return isObject(item);\n  });\n}\nexport function allowAdditionalItems(schema) {\n  if (schema.additionalItems === true) {\n    console.warn(\"additionalItems=true is currently not supported\");\n  }\n\n  return isObject(schema.additionalItems);\n}\nexport function optionsList(schema) {\n  if (schema[\"enum\"]) {\n    return schema[\"enum\"].map(function (value, i) {\n      var label = schema.enumNames && schema.enumNames[i] || String(value);\n      return {\n        label: label,\n        value: value\n      };\n    });\n  } else {\n    var altSchemas = schema.oneOf || schema.anyOf;\n    return altSchemas.map(function (schema, i) {\n      var value = toConstant(schema);\n      var label = schema.title || String(value);\n      return {\n        schema: schema,\n        label: label,\n        value: value\n      };\n    });\n  }\n}\nexport function findSchemaDefinition($ref) {\n  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var origRef = $ref;\n\n  if ($ref.startsWith(\"#\")) {\n    // Decode URI fragment representation.\n    $ref = decodeURIComponent($ref.substring(1));\n  } else {\n    throw new Error(\"Could not find a definition for \".concat(origRef, \".\"));\n  }\n\n  var current = jsonpointer.get(rootSchema, $ref);\n\n  if (current === undefined) {\n    throw new Error(\"Could not find a definition for \".concat(origRef, \".\"));\n  }\n\n  if (current.hasOwnProperty(\"$ref\")) {\n    return findSchemaDefinition(current.$ref, rootSchema);\n  }\n\n  return current;\n} // In the case where we have to implicitly create a schema, it is useful to know what type to use\n//  based on the data we are defining\n\nexport var guessType = function guessType(value) {\n  if (Array.isArray(value)) {\n    return \"array\";\n  } else if (typeof value === \"string\") {\n    return \"string\";\n  } else if (value == null) {\n    return \"null\";\n  } else if (typeof value === \"boolean\") {\n    return \"boolean\";\n  } else if (!isNaN(value)) {\n    return \"number\";\n  } else if (_typeof(value) === \"object\") {\n    return \"object\";\n  } // Default to string if we can't figure it out\n\n\n  return \"string\";\n}; // This function will create new \"properties\" items for each key in our formData\n\nexport function stubExistingAdditionalProperties(schema) {\n  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var formData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {}; // Clone the schema so we don't ruin the consumer's original\n\n  schema = _objectSpread({}, schema, {\n    properties: _objectSpread({}, schema.properties)\n  });\n  Object.keys(formData).forEach(function (key) {\n    if (schema.properties.hasOwnProperty(key)) {\n      // No need to stub, our schema already has the property\n      return;\n    }\n\n    var additionalProperties;\n\n    if (schema.additionalProperties.hasOwnProperty(\"$ref\")) {\n      additionalProperties = retrieveSchema({\n        $ref: schema.additionalProperties[\"$ref\"]\n      }, rootSchema, formData);\n    } else if (schema.additionalProperties.hasOwnProperty(\"type\")) {\n      additionalProperties = _objectSpread({}, schema.additionalProperties);\n    } else {\n      additionalProperties = {\n        type: guessType(formData[key])\n      };\n    } // The type of our new key should match the additionalProperties value;\n\n\n    schema.properties[key] = additionalProperties; // Set our additional property flag so we know it was dynamically added\n\n    schema.properties[key][ADDITIONAL_PROPERTY_FLAG] = true;\n  });\n  return schema;\n}\nexport function resolveSchema(schema) {\n  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var formData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (schema.hasOwnProperty(\"$ref\")) {\n    return resolveReference(schema, rootSchema, formData);\n  } else if (schema.hasOwnProperty(\"dependencies\")) {\n    var resolvedSchema = resolveDependencies(schema, rootSchema, formData);\n    return retrieveSchema(resolvedSchema, rootSchema, formData);\n  } else if (schema.hasOwnProperty(\"allOf\")) {\n    return _objectSpread({}, schema, {\n      allOf: schema.allOf.map(function (allOfSubschema) {\n        return retrieveSchema(allOfSubschema, rootSchema, formData);\n      })\n    });\n  } else {\n    // No $ref or dependencies attribute found, returning the original schema.\n    return schema;\n  }\n}\n\nfunction resolveReference(schema, rootSchema, formData) {\n  // Retrieve the referenced schema definition.\n  var $refSchema = findSchemaDefinition(schema.$ref, rootSchema); // Drop the $ref property of the source schema.\n\n  var $ref = schema.$ref,\n      localSchema = _objectWithoutProperties(schema, [\"$ref\"]); // Update referenced schema definition with local schema properties.\n\n\n  return retrieveSchema(_objectSpread({}, $refSchema, localSchema), rootSchema, formData);\n}\n\nexport function retrieveSchema(schema) {\n  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var formData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (!isObject(schema)) {\n    return {};\n  }\n\n  var resolvedSchema = resolveSchema(schema, rootSchema, formData);\n\n  if (\"allOf\" in schema) {\n    try {\n      resolvedSchema = mergeAllOf(_objectSpread({}, resolvedSchema, {\n        allOf: resolvedSchema.allOf\n      }));\n    } catch (e) {\n      console.warn(\"could not merge subschemas in allOf:\\n\" + e);\n\n      var _resolvedSchema = resolvedSchema,\n          allOf = _resolvedSchema.allOf,\n          resolvedSchemaWithoutAllOf = _objectWithoutProperties(_resolvedSchema, [\"allOf\"]);\n\n      return resolvedSchemaWithoutAllOf;\n    }\n  }\n\n  var hasAdditionalProperties = resolvedSchema.hasOwnProperty(\"additionalProperties\") && resolvedSchema.additionalProperties !== false;\n\n  if (hasAdditionalProperties) {\n    return stubExistingAdditionalProperties(resolvedSchema, rootSchema, formData);\n  }\n\n  return resolvedSchema;\n}\n\nfunction resolveDependencies(schema, rootSchema, formData) {\n  // Drop the dependencies from the source schema.\n  var _schema$dependencies = schema.dependencies,\n      dependencies = _schema$dependencies === void 0 ? {} : _schema$dependencies,\n      resolvedSchema = _objectWithoutProperties(schema, [\"dependencies\"]);\n\n  if (\"oneOf\" in resolvedSchema) {\n    resolvedSchema = resolvedSchema.oneOf[getMatchingOption(formData, resolvedSchema.oneOf, rootSchema)];\n  } else if (\"anyOf\" in resolvedSchema) {\n    resolvedSchema = resolvedSchema.anyOf[getMatchingOption(formData, resolvedSchema.anyOf, rootSchema)];\n  }\n\n  return processDependencies(dependencies, resolvedSchema, rootSchema, formData);\n}\n\nfunction processDependencies(dependencies, resolvedSchema, rootSchema, formData) {\n  // Process dependencies updating the local schema properties as appropriate.\n  for (var dependencyKey in dependencies) {\n    // Skip this dependency if its trigger property is not present.\n    if (formData[dependencyKey] === undefined) {\n      continue;\n    } // Skip this dependency if it is not included in the schema (such as when dependencyKey is itself a hidden dependency.)\n\n\n    if (resolvedSchema.properties && !(dependencyKey in resolvedSchema.properties)) {\n      continue;\n    }\n\n    var dependencyValue = dependencies[dependencyKey],\n        remainingDependencies = _objectWithoutProperties(dependencies, [dependencyKey].map(_toPropertyKey));\n\n    if (Array.isArray(dependencyValue)) {\n      resolvedSchema = withDependentProperties(resolvedSchema, dependencyValue);\n    } else if (isObject(dependencyValue)) {\n      resolvedSchema = withDependentSchema(resolvedSchema, rootSchema, formData, dependencyKey, dependencyValue);\n    }\n\n    return processDependencies(remainingDependencies, resolvedSchema, rootSchema, formData);\n  }\n\n  return resolvedSchema;\n}\n\nfunction withDependentProperties(schema, additionallyRequired) {\n  if (!additionallyRequired) {\n    return schema;\n  }\n\n  var required = Array.isArray(schema.required) ? Array.from(new Set([].concat(_toConsumableArray(schema.required), _toConsumableArray(additionallyRequired)))) : additionallyRequired;\n  return _objectSpread({}, schema, {\n    required: required\n  });\n}\n\nfunction withDependentSchema(schema, rootSchema, formData, dependencyKey, dependencyValue) {\n  var _retrieveSchema = retrieveSchema(dependencyValue, rootSchema, formData),\n      oneOf = _retrieveSchema.oneOf,\n      dependentSchema = _objectWithoutProperties(_retrieveSchema, [\"oneOf\"]);\n\n  schema = mergeSchemas(schema, dependentSchema); // Since it does not contain oneOf, we return the original schema.\n\n  if (oneOf === undefined) {\n    return schema;\n  } else if (!Array.isArray(oneOf)) {\n    throw new Error(\"invalid: it is some \".concat(_typeof(oneOf), \" instead of an array\"));\n  } // Resolve $refs inside oneOf.\n\n\n  var resolvedOneOf = oneOf.map(function (subschema) {\n    return subschema.hasOwnProperty(\"$ref\") ? resolveReference(subschema, rootSchema, formData) : subschema;\n  });\n  return withExactlyOneSubschema(schema, rootSchema, formData, dependencyKey, resolvedOneOf);\n}\n\nfunction withExactlyOneSubschema(schema, rootSchema, formData, dependencyKey, oneOf) {\n  var validSubschemas = oneOf.filter(function (subschema) {\n    if (!subschema.properties) {\n      return false;\n    }\n\n    var conditionPropertySchema = subschema.properties[dependencyKey];\n\n    if (conditionPropertySchema) {\n      var conditionSchema = {\n        type: \"object\",\n        properties: _defineProperty({}, dependencyKey, conditionPropertySchema)\n      };\n\n      var _validateFormData = validateFormData(formData, conditionSchema),\n          errors = _validateFormData.errors;\n\n      return errors.length === 0;\n    }\n  });\n\n  if (validSubschemas.length !== 1) {\n    console.warn(\"ignoring oneOf in dependencies because there isn't exactly one subschema that is valid\");\n    return schema;\n  }\n\n  var subschema = validSubschemas[0];\n\n  var _subschema$properties = subschema.properties,\n      conditionPropertySchema = _subschema$properties[dependencyKey],\n      dependentSubschema = _objectWithoutProperties(_subschema$properties, [dependencyKey].map(_toPropertyKey));\n\n  var dependentSchema = _objectSpread({}, subschema, {\n    properties: dependentSubschema\n  });\n\n  return mergeSchemas(schema, retrieveSchema(dependentSchema, rootSchema, formData));\n} // Recursively merge deeply nested schemas.\n// The difference between mergeSchemas and mergeObjects\n// is that mergeSchemas only concats arrays for\n// values under the \"required\" keyword, and when it does,\n// it doesn't include duplicate values.\n\n\nexport function mergeSchemas(obj1, obj2) {\n  var acc = Object.assign({}, obj1); // Prevent mutation of source object.\n\n  return Object.keys(obj2).reduce(function (acc, key) {\n    var left = obj1 ? obj1[key] : {},\n        right = obj2[key];\n\n    if (obj1 && obj1.hasOwnProperty(key) && isObject(right)) {\n      acc[key] = mergeSchemas(left, right);\n    } else if (obj1 && obj2 && (getSchemaType(obj1) === \"object\" || getSchemaType(obj2) === \"object\") && key === \"required\" && Array.isArray(left) && Array.isArray(right)) {\n      // Don't include duplicate values when merging\n      // \"required\" fields.\n      acc[key] = union(left, right);\n    } else {\n      acc[key] = right;\n    }\n\n    return acc;\n  }, acc);\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) === \"[object Arguments]\";\n}\n\nexport function deepEquals(a, b) {\n  var ca = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var cb = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : []; // Partially extracted from node-deeper and adapted to exclude comparison\n  // checks for functions.\n  // https://github.com/othiym23/node-deeper\n\n  if (a === b) {\n    return true;\n  } else if (typeof a === \"function\" || typeof b === \"function\") {\n    // Assume all functions are equivalent\n    // see https://github.com/rjsf-team/react-jsonschema-form/issues/255\n    return true;\n  } else if (_typeof(a) !== \"object\" || _typeof(b) !== \"object\") {\n    return false;\n  } else if (a === null || b === null) {\n    return false;\n  } else if (a instanceof Date && b instanceof Date) {\n    return a.getTime() === b.getTime();\n  } else if (a instanceof RegExp && b instanceof RegExp) {\n    return a.source === b.source && a.global === b.global && a.multiline === b.multiline && a.lastIndex === b.lastIndex && a.ignoreCase === b.ignoreCase;\n  } else if (isArguments(a) || isArguments(b)) {\n    if (!(isArguments(a) && isArguments(b))) {\n      return false;\n    }\n\n    var slice = Array.prototype.slice;\n    return deepEquals(slice.call(a), slice.call(b), ca, cb);\n  } else {\n    if (a.constructor !== b.constructor) {\n      return false;\n    }\n\n    var ka = Object.keys(a);\n    var kb = Object.keys(b); // don't bother with stack acrobatics if there's nothing there\n\n    if (ka.length === 0 && kb.length === 0) {\n      return true;\n    }\n\n    if (ka.length !== kb.length) {\n      return false;\n    }\n\n    var cal = ca.length;\n\n    while (cal--) {\n      if (ca[cal] === a) {\n        return cb[cal] === b;\n      }\n    }\n\n    ca.push(a);\n    cb.push(b);\n    ka.sort();\n    kb.sort();\n\n    for (var j = ka.length - 1; j >= 0; j--) {\n      if (ka[j] !== kb[j]) {\n        return false;\n      }\n    }\n\n    var _key;\n\n    for (var k = ka.length - 1; k >= 0; k--) {\n      _key = ka[k];\n\n      if (!deepEquals(a[_key], b[_key], ca, cb)) {\n        return false;\n      }\n    }\n\n    ca.pop();\n    cb.pop();\n    return true;\n  }\n}\nexport function shouldRender(comp, nextProps, nextState) {\n  var props = comp.props,\n      state = comp.state;\n  return !deepEquals(props, nextProps) || !deepEquals(state, nextState);\n}\nexport function toIdSchema(schema, id, rootSchema) {\n  var formData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var idPrefix = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"root\";\n  var idSchema = {\n    $id: id || idPrefix\n  };\n\n  if (\"$ref\" in schema || \"dependencies\" in schema || \"allOf\" in schema) {\n    var _schema = retrieveSchema(schema, rootSchema, formData);\n\n    return toIdSchema(_schema, id, rootSchema, formData, idPrefix);\n  }\n\n  if (\"items\" in schema && !schema.items.$ref) {\n    return toIdSchema(schema.items, id, rootSchema, formData, idPrefix);\n  }\n\n  if (schema.type !== \"object\") {\n    return idSchema;\n  }\n\n  for (var name in schema.properties || {}) {\n    var field = schema.properties[name];\n    var fieldId = idSchema.$id + \"_\" + name;\n    idSchema[name] = toIdSchema(isObject(field) ? field : {}, fieldId, rootSchema, // It's possible that formData is not an object -- this can happen if an\n    // array item has just been added, but not populated with data yet\n    (formData || {})[name], idPrefix);\n  }\n\n  return idSchema;\n}\nexport function toPathSchema(schema) {\n  var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  var rootSchema = arguments.length > 2 ? arguments[2] : undefined;\n  var formData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var pathSchema = {\n    $name: name.replace(/^\\./, \"\")\n  };\n\n  if (\"$ref\" in schema || \"dependencies\" in schema || \"allOf\" in schema) {\n    var _schema = retrieveSchema(schema, rootSchema, formData);\n\n    return toPathSchema(_schema, name, rootSchema, formData);\n  }\n\n  if (schema.hasOwnProperty(\"additionalProperties\")) {\n    pathSchema.__rjsf_additionalProperties = true;\n  }\n\n  if (schema.hasOwnProperty(\"items\") && Array.isArray(formData)) {\n    formData.forEach(function (element, i) {\n      pathSchema[i] = toPathSchema(schema.items, \"\".concat(name, \".\").concat(i), rootSchema, element);\n    });\n  } else if (schema.hasOwnProperty(\"properties\")) {\n    for (var property in schema.properties) {\n      pathSchema[property] = toPathSchema(schema.properties[property], \"\".concat(name, \".\").concat(property), rootSchema, // It's possible that formData is not an object -- this can happen if an\n      // array item has just been added, but not populated with data yet\n      (formData || {})[property]);\n    }\n  }\n\n  return pathSchema;\n}\nexport function parseDateString(dateString) {\n  var includeTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n  if (!dateString) {\n    return {\n      year: -1,\n      month: -1,\n      day: -1,\n      hour: includeTime ? -1 : 0,\n      minute: includeTime ? -1 : 0,\n      second: includeTime ? -1 : 0\n    };\n  }\n\n  var date = new Date(dateString);\n\n  if (Number.isNaN(date.getTime())) {\n    throw new Error(\"Unable to parse date \" + dateString);\n  }\n\n  return {\n    year: date.getUTCFullYear(),\n    month: date.getUTCMonth() + 1,\n    // oh you, javascript.\n    day: date.getUTCDate(),\n    hour: includeTime ? date.getUTCHours() : 0,\n    minute: includeTime ? date.getUTCMinutes() : 0,\n    second: includeTime ? date.getUTCSeconds() : 0\n  };\n}\nexport function toDateString(_ref2) {\n  var year = _ref2.year,\n      month = _ref2.month,\n      day = _ref2.day,\n      _ref2$hour = _ref2.hour,\n      hour = _ref2$hour === void 0 ? 0 : _ref2$hour,\n      _ref2$minute = _ref2.minute,\n      minute = _ref2$minute === void 0 ? 0 : _ref2$minute,\n      _ref2$second = _ref2.second,\n      second = _ref2$second === void 0 ? 0 : _ref2$second;\n  var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var utcTime = Date.UTC(year, month - 1, day, hour, minute, second);\n  var datetime = new Date(utcTime).toJSON();\n  return time ? datetime : datetime.slice(0, 10);\n}\nexport function utcToLocal(jsonDate) {\n  if (!jsonDate) {\n    return \"\";\n  } // required format of `\"yyyy-MM-ddThh:mm\" followed by optional \":ss\" or \":ss.SSS\"\n  // https://html.spec.whatwg.org/multipage/input.html#local-date-and-time-state-(type%3Ddatetime-local)\n  // > should be a _valid local date and time string_ (not GMT)\n  // Note - date constructor passed local ISO-8601 does not correctly\n  // change time to UTC in node pre-8\n\n\n  var date = new Date(jsonDate);\n  var yyyy = pad(date.getFullYear(), 4);\n  var MM = pad(date.getMonth() + 1, 2);\n  var dd = pad(date.getDate(), 2);\n  var hh = pad(date.getHours(), 2);\n  var mm = pad(date.getMinutes(), 2);\n  var ss = pad(date.getSeconds(), 2);\n  var SSS = pad(date.getMilliseconds(), 3);\n  return \"\".concat(yyyy, \"-\").concat(MM, \"-\").concat(dd, \"T\").concat(hh, \":\").concat(mm, \":\").concat(ss, \".\").concat(SSS);\n}\nexport function localToUTC(dateString) {\n  if (dateString) {\n    return new Date(dateString).toJSON();\n  }\n}\nexport function pad(num, size) {\n  var s = String(num);\n\n  while (s.length < size) {\n    s = \"0\" + s;\n  }\n\n  return s;\n}\nexport function dataURItoBlob(dataURI) {\n  // Split metadata from data\n  var splitted = dataURI.split(\",\"); // Split params\n\n  var params = splitted[0].split(\";\"); // Get mime-type from params\n\n  var type = params[0].replace(\"data:\", \"\"); // Filter the name property from params\n\n  var properties = params.filter(function (param) {\n    return param.split(\"=\")[0] === \"name\";\n  }); // Look for the name and use unknown if no name property.\n\n  var name;\n\n  if (properties.length !== 1) {\n    name = \"unknown\";\n  } else {\n    // Because we filtered out the other property,\n    // we only have the name case here.\n    name = properties[0].split(\"=\")[1];\n  } // Built the Uint8Array Blob parameter from the base64 string.\n\n\n  var binary = atob(splitted[1]);\n  var array = [];\n\n  for (var _i = 0; _i < binary.length; _i++) {\n    array.push(binary.charCodeAt(_i));\n  } // Create the blob object\n\n\n  var blob = new window.Blob([new Uint8Array(array)], {\n    type: type\n  });\n  return {\n    blob: blob,\n    name: name\n  };\n}\nexport function rangeSpec(schema) {\n  var spec = {};\n\n  if (schema.multipleOf) {\n    spec.step = schema.multipleOf;\n  }\n\n  if (schema.minimum || schema.minimum === 0) {\n    spec.min = schema.minimum;\n  }\n\n  if (schema.maximum || schema.maximum === 0) {\n    spec.max = schema.maximum;\n  }\n\n  return spec;\n}\nexport function getMatchingOption(formData, options, rootSchema) {\n  for (var _i2 = 0; _i2 < options.length; _i2++) {\n    var option = options[_i2]; // If the schema describes an object then we need to add slightly more\n    // strict matching to the schema, because unless the schema uses the\n    // \"requires\" keyword, an object will match the schema as long as it\n    // doesn't have matching keys with a conflicting type. To do this we use an\n    // \"anyOf\" with an array of requires. This augmentation expresses that the\n    // schema should match if any of the keys in the schema are present on the\n    // object and pass validation.\n\n    if (option.properties) {\n      // Create an \"anyOf\" schema that requires at least one of the keys in the\n      // \"properties\" object\n      var requiresAnyOf = {\n        anyOf: Object.keys(option.properties).map(function (key) {\n          return {\n            required: [key]\n          };\n        })\n      };\n      var augmentedSchema = void 0; // If the \"anyOf\" keyword already exists, wrap the augmentation in an \"allOf\"\n\n      if (option.anyOf) {\n        // Create a shallow clone of the option\n        var shallowClone = _extends({}, option);\n\n        if (!shallowClone.allOf) {\n          shallowClone.allOf = [];\n        } else {\n          // If \"allOf\" already exists, shallow clone the array\n          shallowClone.allOf = shallowClone.allOf.slice();\n        }\n\n        shallowClone.allOf.push(requiresAnyOf);\n        augmentedSchema = shallowClone;\n      } else {\n        augmentedSchema = Object.assign({}, option, requiresAnyOf);\n      } // Remove the \"required\" field as it's likely that not all fields have\n      // been filled in yet, which will mean that the schema is not valid\n\n\n      delete augmentedSchema.required;\n\n      if (isValid(augmentedSchema, formData, rootSchema)) {\n        return _i2;\n      }\n    } else if (isValid(option, formData, rootSchema)) {\n      return _i2;\n    }\n  }\n\n  return 0;\n} // Check to see if a schema specifies that a value must be true\n\nexport function schemaRequiresTrueValue(schema) {\n  // Check if const is a truthy value\n  if (schema[\"const\"]) {\n    return true;\n  } // Check if an enum has a single value of true\n\n\n  if (schema[\"enum\"] && schema[\"enum\"].length === 1 && schema[\"enum\"][0] === true) {\n    return true;\n  } // If anyOf has a single value, evaluate the subschema\n\n\n  if (schema.anyOf && schema.anyOf.length === 1) {\n    return schemaRequiresTrueValue(schema.anyOf[0]);\n  } // If oneOf has a single value, evaluate the subschema\n\n\n  if (schema.oneOf && schema.oneOf.length === 1) {\n    return schemaRequiresTrueValue(schema.oneOf[0]);\n  } // Evaluate each subschema in allOf, to see if one of them requires a true\n  // value\n\n\n  if (schema.allOf) {\n    return schema.allOf.some(schemaRequiresTrueValue);\n  }\n\n  return false;\n}","map":{"version":3,"sources":["C:/Users/Akshaj Bansal/json parser/my-app/node_modules/@rjsf/core/dist/es/utils.js"],"names":["_toPropertyKey","arg","key","_toPrimitive","_typeof","String","input","hint","prim","Symbol","toPrimitive","undefined","res","call","TypeError","Number","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","iter","iterator","Object","prototype","toString","Array","from","isArray","i","arr2","length","obj","constructor","_extends","assign","target","arguments","source","hasOwnProperty","apply","_objectSpread","ownKeys","keys","getOwnPropertySymbols","concat","filter","sym","getOwnPropertyDescriptor","enumerable","forEach","_defineProperty","value","defineProperty","configurable","writable","_objectWithoutProperties","excluded","_objectWithoutPropertiesLoose","sourceSymbolKeys","indexOf","propertyIsEnumerable","sourceKeys","React","ReactIs","mergeAllOf","fill","union","jsonpointer","fields","widgets","validateFormData","isValid","ADDITIONAL_PROPERTY_FLAG","widgetMap","checkbox","radio","select","hidden","string","text","password","email","hostname","ipv4","ipv6","uri","textarea","date","datetime","color","file","number","updown","range","integer","array","checkboxes","files","canExpand","schema","uiSchema","formData","additionalProperties","_getUiOptions","getUiOptions","expandable","maxProperties","getDefaultRegistry","definitions","rootSchema","formContext","getSchemaType","type","guessType","properties","includes","find","getWidget","widget","registeredWidgets","mergeOptions","Widget","MergedWidget","defaultOptions","defaultProps","options","_ref","_ref$options","props","createElement","isForwardRef","isMemo","Error","registeredWidget","_registeredWidget","hasWidget","e","message","startsWith","computeDefaults","_schema","parentDefaults","rawFormData","includeUndefinedValues","isObject","defaults","mergeObjects","refSchema","findSchemaDefinition","$ref","resolvedSchema","resolveDependencies","isFixedItems","items","map","itemSchema","idx","oneOf","getMatchingOption","anyOf","reduce","acc","computedDefault","item","additionalItems","minItems","isMultiSelect","defaultsLength","defaultEntries","fillerSchema","fillerEntries","getDefaultFormState","retrieveSchema","mergeDefaultsWithFormData","console","warn","component","substring","getDisplayLabel","uiOptions","_uiOptions$label","label","displayLabel","isFilesArray","thing","File","obj1","obj2","concatArrays","left","right","asNumber","test","n","valid","isNaN","orderProperties","order","arrayToHash","prev","curr","errorPropList","join","propertyHash","orderFiltered","prop","orderHash","rest","restIndex","lastIndexOf","complete","splice","isConstant","toConstant","isSelect","altSchemas","every","uniqueItems","itemsSchema","format","allowAdditionalItems","optionsList","enumNames","title","origRef","decodeURIComponent","current","get","stubExistingAdditionalProperties","resolveSchema","resolveReference","allOf","allOfSubschema","$refSchema","localSchema","_resolvedSchema","resolvedSchemaWithoutAllOf","hasAdditionalProperties","_schema$dependencies","dependencies","processDependencies","dependencyKey","dependencyValue","remainingDependencies","withDependentProperties","withDependentSchema","additionallyRequired","required","Set","_retrieveSchema","dependentSchema","mergeSchemas","resolvedOneOf","subschema","withExactlyOneSubschema","validSubschemas","conditionPropertySchema","conditionSchema","_validateFormData","errors","_subschema$properties","dependentSubschema","isArguments","object","deepEquals","a","b","ca","cb","Date","getTime","RegExp","global","multiline","lastIndex","ignoreCase","slice","ka","kb","cal","push","sort","j","_key","k","pop","shouldRender","comp","nextProps","nextState","state","toIdSchema","id","idPrefix","idSchema","$id","name","field","fieldId","toPathSchema","pathSchema","$name","replace","__rjsf_additionalProperties","element","property","parseDateString","dateString","includeTime","year","month","day","hour","minute","second","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","toDateString","_ref2","_ref2$hour","_ref2$minute","_ref2$second","time","utcTime","UTC","toJSON","utcToLocal","jsonDate","yyyy","pad","getFullYear","MM","getMonth","dd","getDate","hh","getHours","mm","getMinutes","ss","getSeconds","SSS","getMilliseconds","localToUTC","num","size","s","dataURItoBlob","dataURI","splitted","split","params","param","binary","atob","_i","charCodeAt","blob","window","Blob","Uint8Array","rangeSpec","spec","multipleOf","step","minimum","min","maximum","max","_i2","option","requiresAnyOf","augmentedSchema","shallowClone","schemaRequiresTrueValue","some"],"mappings":"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","sourcesContent":["function _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\n\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport React from \"react\";\nimport * as ReactIs from \"react-is\";\nimport mergeAllOf from \"json-schema-merge-allof\";\nimport fill from \"core-js-pure/features/array/fill\";\nimport union from \"lodash/union\";\nimport jsonpointer from \"jsonpointer\";\nimport fields from \"./components/fields\";\nimport widgets from \"./components/widgets\";\nimport validateFormData, { isValid } from \"./validate\";\nexport var ADDITIONAL_PROPERTY_FLAG = \"__additional_property\";\nvar widgetMap = {\n  \"boolean\": {\n    checkbox: \"CheckboxWidget\",\n    radio: \"RadioWidget\",\n    select: \"SelectWidget\",\n    hidden: \"HiddenWidget\"\n  },\n  string: {\n    text: \"TextWidget\",\n    password: \"PasswordWidget\",\n    email: \"EmailWidget\",\n    hostname: \"TextWidget\",\n    ipv4: \"TextWidget\",\n    ipv6: \"TextWidget\",\n    uri: \"URLWidget\",\n    \"data-url\": \"FileWidget\",\n    radio: \"RadioWidget\",\n    select: \"SelectWidget\",\n    textarea: \"TextareaWidget\",\n    hidden: \"HiddenWidget\",\n    date: \"DateWidget\",\n    datetime: \"DateTimeWidget\",\n    \"date-time\": \"DateTimeWidget\",\n    \"alt-date\": \"AltDateWidget\",\n    \"alt-datetime\": \"AltDateTimeWidget\",\n    color: \"ColorWidget\",\n    file: \"FileWidget\"\n  },\n  number: {\n    text: \"TextWidget\",\n    select: \"SelectWidget\",\n    updown: \"UpDownWidget\",\n    range: \"RangeWidget\",\n    radio: \"RadioWidget\",\n    hidden: \"HiddenWidget\"\n  },\n  integer: {\n    text: \"TextWidget\",\n    select: \"SelectWidget\",\n    updown: \"UpDownWidget\",\n    range: \"RangeWidget\",\n    radio: \"RadioWidget\",\n    hidden: \"HiddenWidget\"\n  },\n  array: {\n    select: \"SelectWidget\",\n    checkboxes: \"CheckboxesWidget\",\n    files: \"FileWidget\",\n    hidden: \"HiddenWidget\"\n  }\n};\nexport function canExpand(schema, uiSchema, formData) {\n  if (!schema.additionalProperties) {\n    return false;\n  }\n\n  var _getUiOptions = getUiOptions(uiSchema),\n      expandable = _getUiOptions.expandable;\n\n  if (expandable === false) {\n    return expandable;\n  } // if ui:options.expandable was not explicitly set to false, we can add\n  // another property if we have not exceeded maxProperties yet\n\n\n  if (schema.maxProperties !== undefined) {\n    return Object.keys(formData).length < schema.maxProperties;\n  }\n\n  return true;\n}\nexport function getDefaultRegistry() {\n  return {\n    fields: fields,\n    widgets: widgets,\n    definitions: {},\n    rootSchema: {},\n    formContext: {}\n  };\n}\n/* Gets the type of a given schema. */\n\nexport function getSchemaType(schema) {\n  var type = schema.type;\n\n  if (!type && schema[\"const\"]) {\n    return guessType(schema[\"const\"]);\n  }\n\n  if (!type && schema[\"enum\"]) {\n    return \"string\";\n  }\n\n  if (!type && (schema.properties || schema.additionalProperties)) {\n    return \"object\";\n  }\n\n  if (type instanceof Array && type.length === 2 && type.includes(\"null\")) {\n    return type.find(function (type) {\n      return type !== \"null\";\n    });\n  }\n\n  return type;\n}\nexport function getWidget(schema, widget) {\n  var registeredWidgets = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var type = getSchemaType(schema);\n\n  function mergeOptions(Widget) {\n    // cache return value as property of widget for proper react reconciliation\n    if (!Widget.MergedWidget) {\n      var defaultOptions = Widget.defaultProps && Widget.defaultProps.options || {};\n\n      Widget.MergedWidget = function (_ref) {\n        var _ref$options = _ref.options,\n            options = _ref$options === void 0 ? {} : _ref$options,\n            props = _objectWithoutProperties(_ref, [\"options\"]);\n\n        return React.createElement(Widget, _extends({\n          options: _objectSpread({}, defaultOptions, options)\n        }, props));\n      };\n    }\n\n    return Widget.MergedWidget;\n  }\n\n  if (typeof widget === \"function\" || ReactIs.isForwardRef(React.createElement(widget)) || ReactIs.isMemo(widget)) {\n    return mergeOptions(widget);\n  }\n\n  if (typeof widget !== \"string\") {\n    throw new Error(\"Unsupported widget definition: \".concat(_typeof(widget)));\n  }\n\n  if (registeredWidgets.hasOwnProperty(widget)) {\n    var registeredWidget = registeredWidgets[widget];\n    return getWidget(schema, registeredWidget, registeredWidgets);\n  }\n\n  if (!widgetMap.hasOwnProperty(type)) {\n    throw new Error(\"No widget for type \\\"\".concat(type, \"\\\"\"));\n  }\n\n  if (widgetMap[type].hasOwnProperty(widget)) {\n    var _registeredWidget = registeredWidgets[widgetMap[type][widget]];\n    return getWidget(schema, _registeredWidget, registeredWidgets);\n  }\n\n  throw new Error(\"No widget \\\"\".concat(widget, \"\\\" for type \\\"\").concat(type, \"\\\"\"));\n}\nexport function hasWidget(schema, widget) {\n  var registeredWidgets = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  try {\n    getWidget(schema, widget, registeredWidgets);\n    return true;\n  } catch (e) {\n    if (e.message && (e.message.startsWith(\"No widget\") || e.message.startsWith(\"Unsupported widget\"))) {\n      return false;\n    }\n\n    throw e;\n  }\n}\n\nfunction computeDefaults(_schema, parentDefaults, rootSchema) {\n  var rawFormData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var includeUndefinedValues = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  var schema = isObject(_schema) ? _schema : {};\n  var formData = isObject(rawFormData) ? rawFormData : {}; // Compute the defaults recursively: give highest priority to deepest nodes.\n\n  var defaults = parentDefaults;\n\n  if (isObject(defaults) && isObject(schema[\"default\"])) {\n    // For object defaults, only override parent defaults that are defined in\n    // schema.default.\n    defaults = mergeObjects(defaults, schema[\"default\"]);\n  } else if (\"default\" in schema) {\n    // Use schema defaults for this node.\n    defaults = schema[\"default\"];\n  } else if (\"$ref\" in schema) {\n    // Use referenced schema defaults for this node.\n    var refSchema = findSchemaDefinition(schema.$ref, rootSchema);\n    return computeDefaults(refSchema, defaults, rootSchema, formData, includeUndefinedValues);\n  } else if (\"dependencies\" in schema) {\n    var resolvedSchema = resolveDependencies(schema, rootSchema, formData);\n    return computeDefaults(resolvedSchema, defaults, rootSchema, formData, includeUndefinedValues);\n  } else if (isFixedItems(schema)) {\n    defaults = schema.items.map(function (itemSchema, idx) {\n      return computeDefaults(itemSchema, Array.isArray(parentDefaults) ? parentDefaults[idx] : undefined, rootSchema, formData, includeUndefinedValues);\n    });\n  } else if (\"oneOf\" in schema) {\n    schema = schema.oneOf[getMatchingOption(undefined, schema.oneOf, rootSchema)];\n  } else if (\"anyOf\" in schema) {\n    schema = schema.anyOf[getMatchingOption(undefined, schema.anyOf, rootSchema)];\n  } // Not defaults defined for this node, fallback to generic typed ones.\n\n\n  if (typeof defaults === \"undefined\") {\n    defaults = schema[\"default\"];\n  }\n\n  switch (getSchemaType(schema)) {\n    // We need to recur for object schema inner default values.\n    case \"object\":\n      return Object.keys(schema.properties || {}).reduce(function (acc, key) {\n        // Compute the defaults for this node, with the parent defaults we might\n        // have from a previous run: defaults[key].\n        var computedDefault = computeDefaults(schema.properties[key], (defaults || {})[key], rootSchema, (formData || {})[key], includeUndefinedValues);\n\n        if (includeUndefinedValues || computedDefault !== undefined) {\n          acc[key] = computedDefault;\n        }\n\n        return acc;\n      }, {});\n\n    case \"array\":\n      // Inject defaults into existing array defaults\n      if (Array.isArray(defaults)) {\n        defaults = defaults.map(function (item, idx) {\n          return computeDefaults(schema.items[idx] || schema.additionalItems || {}, item, rootSchema);\n        });\n      } // Deeply inject defaults into already existing form data\n\n\n      if (Array.isArray(rawFormData)) {\n        defaults = rawFormData.map(function (item, idx) {\n          return computeDefaults(schema.items, (defaults || {})[idx], rootSchema, item);\n        });\n      }\n\n      if (schema.minItems) {\n        if (!isMultiSelect(schema, rootSchema)) {\n          var defaultsLength = defaults ? defaults.length : 0;\n\n          if (schema.minItems > defaultsLength) {\n            var defaultEntries = defaults || []; // populate the array with the defaults\n\n            var fillerSchema = Array.isArray(schema.items) ? schema.additionalItems : schema.items;\n            var fillerEntries = fill(new Array(schema.minItems - defaultsLength), computeDefaults(fillerSchema, fillerSchema.defaults, rootSchema)); // then fill up the rest with either the item default or empty, up to minItems\n\n            return defaultEntries.concat(fillerEntries);\n          }\n        } else {\n          return defaults ? defaults : [];\n        }\n      }\n\n  }\n\n  return defaults;\n}\n\nexport function getDefaultFormState(_schema, formData) {\n  var rootSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var includeUndefinedValues = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n  if (!isObject(_schema)) {\n    throw new Error(\"Invalid schema: \" + _schema);\n  }\n\n  var schema = retrieveSchema(_schema, rootSchema, formData);\n  var defaults = computeDefaults(schema, _schema[\"default\"], rootSchema, formData, includeUndefinedValues);\n\n  if (typeof formData === \"undefined\") {\n    // No form data? Use schema defaults.\n    return defaults;\n  }\n\n  if (isObject(formData) || Array.isArray(formData)) {\n    return mergeDefaultsWithFormData(defaults, formData);\n  }\n\n  if (formData === 0 || formData === false || formData === \"\") {\n    return formData;\n  }\n\n  return formData || defaults;\n}\n/**\n * When merging defaults and form data, we want to merge in this specific way:\n * - objects are deeply merged\n * - arrays are merged in such a way that:\n *   - when the array is set in form data, only array entries set in form data\n *     are deeply merged; additional entries from the defaults are ignored\n *   - when the array is not set in form data, the default is copied over\n * - scalars are overwritten/set by form data\n */\n\nexport function mergeDefaultsWithFormData(defaults, formData) {\n  if (Array.isArray(formData)) {\n    if (!Array.isArray(defaults)) {\n      defaults = [];\n    }\n\n    return formData.map(function (value, idx) {\n      if (defaults[idx]) {\n        return mergeDefaultsWithFormData(defaults[idx], value);\n      }\n\n      return value;\n    });\n  } else if (isObject(formData)) {\n    var acc = Object.assign({}, defaults); // Prevent mutation of source object.\n\n    return Object.keys(formData).reduce(function (acc, key) {\n      acc[key] = mergeDefaultsWithFormData(defaults ? defaults[key] : {}, formData[key]);\n      return acc;\n    }, acc);\n  } else {\n    return formData;\n  }\n}\nexport function getUiOptions(uiSchema) {\n  // get all passed options from ui:widget, ui:options, and ui:<optionName>\n  return Object.keys(uiSchema).filter(function (key) {\n    return key.indexOf(\"ui:\") === 0;\n  }).reduce(function (options, key) {\n    var value = uiSchema[key];\n\n    if (key === \"ui:widget\" && isObject(value)) {\n      console.warn(\"Setting options via ui:widget object is deprecated, use ui:options instead\");\n      return _objectSpread({}, options, value.options || {}, {\n        widget: value.component\n      });\n    }\n\n    if (key === \"ui:options\" && isObject(value)) {\n      return _objectSpread({}, options, value);\n    }\n\n    return _objectSpread({}, options, _defineProperty({}, key.substring(3), value));\n  }, {});\n}\nexport function getDisplayLabel(schema, uiSchema, rootSchema) {\n  var uiOptions = getUiOptions(uiSchema);\n  var _uiOptions$label = uiOptions.label,\n      displayLabel = _uiOptions$label === void 0 ? true : _uiOptions$label;\n\n  if (schema.type === \"array\") {\n    displayLabel = isMultiSelect(schema, rootSchema) || isFilesArray(schema, uiSchema, rootSchema);\n  }\n\n  if (schema.type === \"object\") {\n    displayLabel = false;\n  }\n\n  if (schema.type === \"boolean\" && !uiSchema[\"ui:widget\"]) {\n    displayLabel = false;\n  }\n\n  if (uiSchema[\"ui:field\"]) {\n    displayLabel = false;\n  }\n\n  return displayLabel;\n}\nexport function isObject(thing) {\n  if (typeof File !== \"undefined\" && thing instanceof File) {\n    return false;\n  }\n\n  return _typeof(thing) === \"object\" && thing !== null && !Array.isArray(thing);\n}\nexport function mergeObjects(obj1, obj2) {\n  var concatArrays = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  // Recursively merge deeply nested objects.\n  var acc = Object.assign({}, obj1); // Prevent mutation of source object.\n\n  return Object.keys(obj2).reduce(function (acc, key) {\n    var left = obj1 ? obj1[key] : {},\n        right = obj2[key];\n\n    if (obj1 && obj1.hasOwnProperty(key) && isObject(right)) {\n      acc[key] = mergeObjects(left, right, concatArrays);\n    } else if (concatArrays && Array.isArray(left) && Array.isArray(right)) {\n      acc[key] = left.concat(right);\n    } else {\n      acc[key] = right;\n    }\n\n    return acc;\n  }, acc);\n}\nexport function asNumber(value) {\n  if (value === \"\") {\n    return undefined;\n  }\n\n  if (value === null) {\n    return null;\n  }\n\n  if (/\\.$/.test(value)) {\n    // \"3.\" can't really be considered a number even if it parses in js. The\n    // user is most likely entering a float.\n    return value;\n  }\n\n  if (/\\.0$/.test(value)) {\n    // we need to return this as a string here, to allow for input like 3.07\n    return value;\n  }\n\n  var n = Number(value);\n  var valid = typeof n === \"number\" && !Number.isNaN(n);\n\n  if (/\\.\\d*0$/.test(value)) {\n    // It's a number, that's cool - but we need it as a string so it doesn't screw\n    // with the user when entering dollar amounts or other values (such as those with\n    // specific precision or number of significant digits)\n    return value;\n  }\n\n  return valid ? n : value;\n}\nexport function orderProperties(properties, order) {\n  if (!Array.isArray(order)) {\n    return properties;\n  }\n\n  var arrayToHash = function arrayToHash(arr) {\n    return arr.reduce(function (prev, curr) {\n      prev[curr] = true;\n      return prev;\n    }, {});\n  };\n\n  var errorPropList = function errorPropList(arr) {\n    return arr.length > 1 ? \"properties '\".concat(arr.join(\"', '\"), \"'\") : \"property '\".concat(arr[0], \"'\");\n  };\n\n  var propertyHash = arrayToHash(properties);\n  var orderFiltered = order.filter(function (prop) {\n    return prop === \"*\" || propertyHash[prop];\n  });\n  var orderHash = arrayToHash(orderFiltered);\n  var rest = properties.filter(function (prop) {\n    return !orderHash[prop];\n  });\n  var restIndex = orderFiltered.indexOf(\"*\");\n\n  if (restIndex === -1) {\n    if (rest.length) {\n      throw new Error(\"uiSchema order list does not contain \".concat(errorPropList(rest)));\n    }\n\n    return orderFiltered;\n  }\n\n  if (restIndex !== orderFiltered.lastIndexOf(\"*\")) {\n    throw new Error(\"uiSchema order list contains more than one wildcard item\");\n  }\n\n  var complete = _toConsumableArray(orderFiltered);\n\n  complete.splice.apply(complete, [restIndex, 1].concat(_toConsumableArray(rest)));\n  return complete;\n}\n/**\n * This function checks if the given schema matches a single\n * constant value.\n */\n\nexport function isConstant(schema) {\n  return Array.isArray(schema[\"enum\"]) && schema[\"enum\"].length === 1 || schema.hasOwnProperty(\"const\");\n}\nexport function toConstant(schema) {\n  if (Array.isArray(schema[\"enum\"]) && schema[\"enum\"].length === 1) {\n    return schema[\"enum\"][0];\n  } else if (schema.hasOwnProperty(\"const\")) {\n    return schema[\"const\"];\n  } else {\n    throw new Error(\"schema cannot be inferred as a constant\");\n  }\n}\nexport function isSelect(_schema) {\n  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var schema = retrieveSchema(_schema, rootSchema);\n  var altSchemas = schema.oneOf || schema.anyOf;\n\n  if (Array.isArray(schema[\"enum\"])) {\n    return true;\n  } else if (Array.isArray(altSchemas)) {\n    return altSchemas.every(function (altSchemas) {\n      return isConstant(altSchemas);\n    });\n  }\n\n  return false;\n}\nexport function isMultiSelect(schema) {\n  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!schema.uniqueItems || !schema.items) {\n    return false;\n  }\n\n  return isSelect(schema.items, rootSchema);\n}\nexport function isFilesArray(schema, uiSchema) {\n  var rootSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (uiSchema[\"ui:widget\"] === \"files\") {\n    return true;\n  } else if (schema.items) {\n    var itemsSchema = retrieveSchema(schema.items, rootSchema);\n    return itemsSchema.type === \"string\" && itemsSchema.format === \"data-url\";\n  }\n\n  return false;\n}\nexport function isFixedItems(schema) {\n  return Array.isArray(schema.items) && schema.items.length > 0 && schema.items.every(function (item) {\n    return isObject(item);\n  });\n}\nexport function allowAdditionalItems(schema) {\n  if (schema.additionalItems === true) {\n    console.warn(\"additionalItems=true is currently not supported\");\n  }\n\n  return isObject(schema.additionalItems);\n}\nexport function optionsList(schema) {\n  if (schema[\"enum\"]) {\n    return schema[\"enum\"].map(function (value, i) {\n      var label = schema.enumNames && schema.enumNames[i] || String(value);\n      return {\n        label: label,\n        value: value\n      };\n    });\n  } else {\n    var altSchemas = schema.oneOf || schema.anyOf;\n    return altSchemas.map(function (schema, i) {\n      var value = toConstant(schema);\n      var label = schema.title || String(value);\n      return {\n        schema: schema,\n        label: label,\n        value: value\n      };\n    });\n  }\n}\nexport function findSchemaDefinition($ref) {\n  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var origRef = $ref;\n\n  if ($ref.startsWith(\"#\")) {\n    // Decode URI fragment representation.\n    $ref = decodeURIComponent($ref.substring(1));\n  } else {\n    throw new Error(\"Could not find a definition for \".concat(origRef, \".\"));\n  }\n\n  var current = jsonpointer.get(rootSchema, $ref);\n\n  if (current === undefined) {\n    throw new Error(\"Could not find a definition for \".concat(origRef, \".\"));\n  }\n\n  if (current.hasOwnProperty(\"$ref\")) {\n    return findSchemaDefinition(current.$ref, rootSchema);\n  }\n\n  return current;\n} // In the case where we have to implicitly create a schema, it is useful to know what type to use\n//  based on the data we are defining\n\nexport var guessType = function guessType(value) {\n  if (Array.isArray(value)) {\n    return \"array\";\n  } else if (typeof value === \"string\") {\n    return \"string\";\n  } else if (value == null) {\n    return \"null\";\n  } else if (typeof value === \"boolean\") {\n    return \"boolean\";\n  } else if (!isNaN(value)) {\n    return \"number\";\n  } else if (_typeof(value) === \"object\") {\n    return \"object\";\n  } // Default to string if we can't figure it out\n\n\n  return \"string\";\n}; // This function will create new \"properties\" items for each key in our formData\n\nexport function stubExistingAdditionalProperties(schema) {\n  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var formData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  // Clone the schema so we don't ruin the consumer's original\n  schema = _objectSpread({}, schema, {\n    properties: _objectSpread({}, schema.properties)\n  });\n  Object.keys(formData).forEach(function (key) {\n    if (schema.properties.hasOwnProperty(key)) {\n      // No need to stub, our schema already has the property\n      return;\n    }\n\n    var additionalProperties;\n\n    if (schema.additionalProperties.hasOwnProperty(\"$ref\")) {\n      additionalProperties = retrieveSchema({\n        $ref: schema.additionalProperties[\"$ref\"]\n      }, rootSchema, formData);\n    } else if (schema.additionalProperties.hasOwnProperty(\"type\")) {\n      additionalProperties = _objectSpread({}, schema.additionalProperties);\n    } else {\n      additionalProperties = {\n        type: guessType(formData[key])\n      };\n    } // The type of our new key should match the additionalProperties value;\n\n\n    schema.properties[key] = additionalProperties; // Set our additional property flag so we know it was dynamically added\n\n    schema.properties[key][ADDITIONAL_PROPERTY_FLAG] = true;\n  });\n  return schema;\n}\nexport function resolveSchema(schema) {\n  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var formData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (schema.hasOwnProperty(\"$ref\")) {\n    return resolveReference(schema, rootSchema, formData);\n  } else if (schema.hasOwnProperty(\"dependencies\")) {\n    var resolvedSchema = resolveDependencies(schema, rootSchema, formData);\n    return retrieveSchema(resolvedSchema, rootSchema, formData);\n  } else if (schema.hasOwnProperty(\"allOf\")) {\n    return _objectSpread({}, schema, {\n      allOf: schema.allOf.map(function (allOfSubschema) {\n        return retrieveSchema(allOfSubschema, rootSchema, formData);\n      })\n    });\n  } else {\n    // No $ref or dependencies attribute found, returning the original schema.\n    return schema;\n  }\n}\n\nfunction resolveReference(schema, rootSchema, formData) {\n  // Retrieve the referenced schema definition.\n  var $refSchema = findSchemaDefinition(schema.$ref, rootSchema); // Drop the $ref property of the source schema.\n\n  var $ref = schema.$ref,\n      localSchema = _objectWithoutProperties(schema, [\"$ref\"]); // Update referenced schema definition with local schema properties.\n\n\n  return retrieveSchema(_objectSpread({}, $refSchema, localSchema), rootSchema, formData);\n}\n\nexport function retrieveSchema(schema) {\n  var rootSchema = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var formData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (!isObject(schema)) {\n    return {};\n  }\n\n  var resolvedSchema = resolveSchema(schema, rootSchema, formData);\n\n  if (\"allOf\" in schema) {\n    try {\n      resolvedSchema = mergeAllOf(_objectSpread({}, resolvedSchema, {\n        allOf: resolvedSchema.allOf\n      }));\n    } catch (e) {\n      console.warn(\"could not merge subschemas in allOf:\\n\" + e);\n\n      var _resolvedSchema = resolvedSchema,\n          allOf = _resolvedSchema.allOf,\n          resolvedSchemaWithoutAllOf = _objectWithoutProperties(_resolvedSchema, [\"allOf\"]);\n\n      return resolvedSchemaWithoutAllOf;\n    }\n  }\n\n  var hasAdditionalProperties = resolvedSchema.hasOwnProperty(\"additionalProperties\") && resolvedSchema.additionalProperties !== false;\n\n  if (hasAdditionalProperties) {\n    return stubExistingAdditionalProperties(resolvedSchema, rootSchema, formData);\n  }\n\n  return resolvedSchema;\n}\n\nfunction resolveDependencies(schema, rootSchema, formData) {\n  // Drop the dependencies from the source schema.\n  var _schema$dependencies = schema.dependencies,\n      dependencies = _schema$dependencies === void 0 ? {} : _schema$dependencies,\n      resolvedSchema = _objectWithoutProperties(schema, [\"dependencies\"]);\n\n  if (\"oneOf\" in resolvedSchema) {\n    resolvedSchema = resolvedSchema.oneOf[getMatchingOption(formData, resolvedSchema.oneOf, rootSchema)];\n  } else if (\"anyOf\" in resolvedSchema) {\n    resolvedSchema = resolvedSchema.anyOf[getMatchingOption(formData, resolvedSchema.anyOf, rootSchema)];\n  }\n\n  return processDependencies(dependencies, resolvedSchema, rootSchema, formData);\n}\n\nfunction processDependencies(dependencies, resolvedSchema, rootSchema, formData) {\n  // Process dependencies updating the local schema properties as appropriate.\n  for (var dependencyKey in dependencies) {\n    // Skip this dependency if its trigger property is not present.\n    if (formData[dependencyKey] === undefined) {\n      continue;\n    } // Skip this dependency if it is not included in the schema (such as when dependencyKey is itself a hidden dependency.)\n\n\n    if (resolvedSchema.properties && !(dependencyKey in resolvedSchema.properties)) {\n      continue;\n    }\n\n    var dependencyValue = dependencies[dependencyKey],\n        remainingDependencies = _objectWithoutProperties(dependencies, [dependencyKey].map(_toPropertyKey));\n\n    if (Array.isArray(dependencyValue)) {\n      resolvedSchema = withDependentProperties(resolvedSchema, dependencyValue);\n    } else if (isObject(dependencyValue)) {\n      resolvedSchema = withDependentSchema(resolvedSchema, rootSchema, formData, dependencyKey, dependencyValue);\n    }\n\n    return processDependencies(remainingDependencies, resolvedSchema, rootSchema, formData);\n  }\n\n  return resolvedSchema;\n}\n\nfunction withDependentProperties(schema, additionallyRequired) {\n  if (!additionallyRequired) {\n    return schema;\n  }\n\n  var required = Array.isArray(schema.required) ? Array.from(new Set([].concat(_toConsumableArray(schema.required), _toConsumableArray(additionallyRequired)))) : additionallyRequired;\n  return _objectSpread({}, schema, {\n    required: required\n  });\n}\n\nfunction withDependentSchema(schema, rootSchema, formData, dependencyKey, dependencyValue) {\n  var _retrieveSchema = retrieveSchema(dependencyValue, rootSchema, formData),\n      oneOf = _retrieveSchema.oneOf,\n      dependentSchema = _objectWithoutProperties(_retrieveSchema, [\"oneOf\"]);\n\n  schema = mergeSchemas(schema, dependentSchema); // Since it does not contain oneOf, we return the original schema.\n\n  if (oneOf === undefined) {\n    return schema;\n  } else if (!Array.isArray(oneOf)) {\n    throw new Error(\"invalid: it is some \".concat(_typeof(oneOf), \" instead of an array\"));\n  } // Resolve $refs inside oneOf.\n\n\n  var resolvedOneOf = oneOf.map(function (subschema) {\n    return subschema.hasOwnProperty(\"$ref\") ? resolveReference(subschema, rootSchema, formData) : subschema;\n  });\n  return withExactlyOneSubschema(schema, rootSchema, formData, dependencyKey, resolvedOneOf);\n}\n\nfunction withExactlyOneSubschema(schema, rootSchema, formData, dependencyKey, oneOf) {\n  var validSubschemas = oneOf.filter(function (subschema) {\n    if (!subschema.properties) {\n      return false;\n    }\n\n    var conditionPropertySchema = subschema.properties[dependencyKey];\n\n    if (conditionPropertySchema) {\n      var conditionSchema = {\n        type: \"object\",\n        properties: _defineProperty({}, dependencyKey, conditionPropertySchema)\n      };\n\n      var _validateFormData = validateFormData(formData, conditionSchema),\n          errors = _validateFormData.errors;\n\n      return errors.length === 0;\n    }\n  });\n\n  if (validSubschemas.length !== 1) {\n    console.warn(\"ignoring oneOf in dependencies because there isn't exactly one subschema that is valid\");\n    return schema;\n  }\n\n  var subschema = validSubschemas[0];\n\n  var _subschema$properties = subschema.properties,\n      conditionPropertySchema = _subschema$properties[dependencyKey],\n      dependentSubschema = _objectWithoutProperties(_subschema$properties, [dependencyKey].map(_toPropertyKey));\n\n  var dependentSchema = _objectSpread({}, subschema, {\n    properties: dependentSubschema\n  });\n\n  return mergeSchemas(schema, retrieveSchema(dependentSchema, rootSchema, formData));\n} // Recursively merge deeply nested schemas.\n// The difference between mergeSchemas and mergeObjects\n// is that mergeSchemas only concats arrays for\n// values under the \"required\" keyword, and when it does,\n// it doesn't include duplicate values.\n\n\nexport function mergeSchemas(obj1, obj2) {\n  var acc = Object.assign({}, obj1); // Prevent mutation of source object.\n\n  return Object.keys(obj2).reduce(function (acc, key) {\n    var left = obj1 ? obj1[key] : {},\n        right = obj2[key];\n\n    if (obj1 && obj1.hasOwnProperty(key) && isObject(right)) {\n      acc[key] = mergeSchemas(left, right);\n    } else if (obj1 && obj2 && (getSchemaType(obj1) === \"object\" || getSchemaType(obj2) === \"object\") && key === \"required\" && Array.isArray(left) && Array.isArray(right)) {\n      // Don't include duplicate values when merging\n      // \"required\" fields.\n      acc[key] = union(left, right);\n    } else {\n      acc[key] = right;\n    }\n\n    return acc;\n  }, acc);\n}\n\nfunction isArguments(object) {\n  return Object.prototype.toString.call(object) === \"[object Arguments]\";\n}\n\nexport function deepEquals(a, b) {\n  var ca = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  var cb = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n\n  // Partially extracted from node-deeper and adapted to exclude comparison\n  // checks for functions.\n  // https://github.com/othiym23/node-deeper\n  if (a === b) {\n    return true;\n  } else if (typeof a === \"function\" || typeof b === \"function\") {\n    // Assume all functions are equivalent\n    // see https://github.com/rjsf-team/react-jsonschema-form/issues/255\n    return true;\n  } else if (_typeof(a) !== \"object\" || _typeof(b) !== \"object\") {\n    return false;\n  } else if (a === null || b === null) {\n    return false;\n  } else if (a instanceof Date && b instanceof Date) {\n    return a.getTime() === b.getTime();\n  } else if (a instanceof RegExp && b instanceof RegExp) {\n    return a.source === b.source && a.global === b.global && a.multiline === b.multiline && a.lastIndex === b.lastIndex && a.ignoreCase === b.ignoreCase;\n  } else if (isArguments(a) || isArguments(b)) {\n    if (!(isArguments(a) && isArguments(b))) {\n      return false;\n    }\n\n    var slice = Array.prototype.slice;\n    return deepEquals(slice.call(a), slice.call(b), ca, cb);\n  } else {\n    if (a.constructor !== b.constructor) {\n      return false;\n    }\n\n    var ka = Object.keys(a);\n    var kb = Object.keys(b); // don't bother with stack acrobatics if there's nothing there\n\n    if (ka.length === 0 && kb.length === 0) {\n      return true;\n    }\n\n    if (ka.length !== kb.length) {\n      return false;\n    }\n\n    var cal = ca.length;\n\n    while (cal--) {\n      if (ca[cal] === a) {\n        return cb[cal] === b;\n      }\n    }\n\n    ca.push(a);\n    cb.push(b);\n    ka.sort();\n    kb.sort();\n\n    for (var j = ka.length - 1; j >= 0; j--) {\n      if (ka[j] !== kb[j]) {\n        return false;\n      }\n    }\n\n    var _key;\n\n    for (var k = ka.length - 1; k >= 0; k--) {\n      _key = ka[k];\n\n      if (!deepEquals(a[_key], b[_key], ca, cb)) {\n        return false;\n      }\n    }\n\n    ca.pop();\n    cb.pop();\n    return true;\n  }\n}\nexport function shouldRender(comp, nextProps, nextState) {\n  var props = comp.props,\n      state = comp.state;\n  return !deepEquals(props, nextProps) || !deepEquals(state, nextState);\n}\nexport function toIdSchema(schema, id, rootSchema) {\n  var formData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var idPrefix = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"root\";\n  var idSchema = {\n    $id: id || idPrefix\n  };\n\n  if (\"$ref\" in schema || \"dependencies\" in schema || \"allOf\" in schema) {\n    var _schema = retrieveSchema(schema, rootSchema, formData);\n\n    return toIdSchema(_schema, id, rootSchema, formData, idPrefix);\n  }\n\n  if (\"items\" in schema && !schema.items.$ref) {\n    return toIdSchema(schema.items, id, rootSchema, formData, idPrefix);\n  }\n\n  if (schema.type !== \"object\") {\n    return idSchema;\n  }\n\n  for (var name in schema.properties || {}) {\n    var field = schema.properties[name];\n    var fieldId = idSchema.$id + \"_\" + name;\n    idSchema[name] = toIdSchema(isObject(field) ? field : {}, fieldId, rootSchema, // It's possible that formData is not an object -- this can happen if an\n    // array item has just been added, but not populated with data yet\n    (formData || {})[name], idPrefix);\n  }\n\n  return idSchema;\n}\nexport function toPathSchema(schema) {\n  var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  var rootSchema = arguments.length > 2 ? arguments[2] : undefined;\n  var formData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var pathSchema = {\n    $name: name.replace(/^\\./, \"\")\n  };\n\n  if (\"$ref\" in schema || \"dependencies\" in schema || \"allOf\" in schema) {\n    var _schema = retrieveSchema(schema, rootSchema, formData);\n\n    return toPathSchema(_schema, name, rootSchema, formData);\n  }\n\n  if (schema.hasOwnProperty(\"additionalProperties\")) {\n    pathSchema.__rjsf_additionalProperties = true;\n  }\n\n  if (schema.hasOwnProperty(\"items\") && Array.isArray(formData)) {\n    formData.forEach(function (element, i) {\n      pathSchema[i] = toPathSchema(schema.items, \"\".concat(name, \".\").concat(i), rootSchema, element);\n    });\n  } else if (schema.hasOwnProperty(\"properties\")) {\n    for (var property in schema.properties) {\n      pathSchema[property] = toPathSchema(schema.properties[property], \"\".concat(name, \".\").concat(property), rootSchema, // It's possible that formData is not an object -- this can happen if an\n      // array item has just been added, but not populated with data yet\n      (formData || {})[property]);\n    }\n  }\n\n  return pathSchema;\n}\nexport function parseDateString(dateString) {\n  var includeTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n  if (!dateString) {\n    return {\n      year: -1,\n      month: -1,\n      day: -1,\n      hour: includeTime ? -1 : 0,\n      minute: includeTime ? -1 : 0,\n      second: includeTime ? -1 : 0\n    };\n  }\n\n  var date = new Date(dateString);\n\n  if (Number.isNaN(date.getTime())) {\n    throw new Error(\"Unable to parse date \" + dateString);\n  }\n\n  return {\n    year: date.getUTCFullYear(),\n    month: date.getUTCMonth() + 1,\n    // oh you, javascript.\n    day: date.getUTCDate(),\n    hour: includeTime ? date.getUTCHours() : 0,\n    minute: includeTime ? date.getUTCMinutes() : 0,\n    second: includeTime ? date.getUTCSeconds() : 0\n  };\n}\nexport function toDateString(_ref2) {\n  var year = _ref2.year,\n      month = _ref2.month,\n      day = _ref2.day,\n      _ref2$hour = _ref2.hour,\n      hour = _ref2$hour === void 0 ? 0 : _ref2$hour,\n      _ref2$minute = _ref2.minute,\n      minute = _ref2$minute === void 0 ? 0 : _ref2$minute,\n      _ref2$second = _ref2.second,\n      second = _ref2$second === void 0 ? 0 : _ref2$second;\n  var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var utcTime = Date.UTC(year, month - 1, day, hour, minute, second);\n  var datetime = new Date(utcTime).toJSON();\n  return time ? datetime : datetime.slice(0, 10);\n}\nexport function utcToLocal(jsonDate) {\n  if (!jsonDate) {\n    return \"\";\n  } // required format of `\"yyyy-MM-ddThh:mm\" followed by optional \":ss\" or \":ss.SSS\"\n  // https://html.spec.whatwg.org/multipage/input.html#local-date-and-time-state-(type%3Ddatetime-local)\n  // > should be a _valid local date and time string_ (not GMT)\n  // Note - date constructor passed local ISO-8601 does not correctly\n  // change time to UTC in node pre-8\n\n\n  var date = new Date(jsonDate);\n  var yyyy = pad(date.getFullYear(), 4);\n  var MM = pad(date.getMonth() + 1, 2);\n  var dd = pad(date.getDate(), 2);\n  var hh = pad(date.getHours(), 2);\n  var mm = pad(date.getMinutes(), 2);\n  var ss = pad(date.getSeconds(), 2);\n  var SSS = pad(date.getMilliseconds(), 3);\n  return \"\".concat(yyyy, \"-\").concat(MM, \"-\").concat(dd, \"T\").concat(hh, \":\").concat(mm, \":\").concat(ss, \".\").concat(SSS);\n}\nexport function localToUTC(dateString) {\n  if (dateString) {\n    return new Date(dateString).toJSON();\n  }\n}\nexport function pad(num, size) {\n  var s = String(num);\n\n  while (s.length < size) {\n    s = \"0\" + s;\n  }\n\n  return s;\n}\nexport function dataURItoBlob(dataURI) {\n  // Split metadata from data\n  var splitted = dataURI.split(\",\"); // Split params\n\n  var params = splitted[0].split(\";\"); // Get mime-type from params\n\n  var type = params[0].replace(\"data:\", \"\"); // Filter the name property from params\n\n  var properties = params.filter(function (param) {\n    return param.split(\"=\")[0] === \"name\";\n  }); // Look for the name and use unknown if no name property.\n\n  var name;\n\n  if (properties.length !== 1) {\n    name = \"unknown\";\n  } else {\n    // Because we filtered out the other property,\n    // we only have the name case here.\n    name = properties[0].split(\"=\")[1];\n  } // Built the Uint8Array Blob parameter from the base64 string.\n\n\n  var binary = atob(splitted[1]);\n  var array = [];\n\n  for (var _i = 0; _i < binary.length; _i++) {\n    array.push(binary.charCodeAt(_i));\n  } // Create the blob object\n\n\n  var blob = new window.Blob([new Uint8Array(array)], {\n    type: type\n  });\n  return {\n    blob: blob,\n    name: name\n  };\n}\nexport function rangeSpec(schema) {\n  var spec = {};\n\n  if (schema.multipleOf) {\n    spec.step = schema.multipleOf;\n  }\n\n  if (schema.minimum || schema.minimum === 0) {\n    spec.min = schema.minimum;\n  }\n\n  if (schema.maximum || schema.maximum === 0) {\n    spec.max = schema.maximum;\n  }\n\n  return spec;\n}\nexport function getMatchingOption(formData, options, rootSchema) {\n  for (var _i2 = 0; _i2 < options.length; _i2++) {\n    var option = options[_i2]; // If the schema describes an object then we need to add slightly more\n    // strict matching to the schema, because unless the schema uses the\n    // \"requires\" keyword, an object will match the schema as long as it\n    // doesn't have matching keys with a conflicting type. To do this we use an\n    // \"anyOf\" with an array of requires. This augmentation expresses that the\n    // schema should match if any of the keys in the schema are present on the\n    // object and pass validation.\n\n    if (option.properties) {\n      // Create an \"anyOf\" schema that requires at least one of the keys in the\n      // \"properties\" object\n      var requiresAnyOf = {\n        anyOf: Object.keys(option.properties).map(function (key) {\n          return {\n            required: [key]\n          };\n        })\n      };\n      var augmentedSchema = void 0; // If the \"anyOf\" keyword already exists, wrap the augmentation in an \"allOf\"\n\n      if (option.anyOf) {\n        // Create a shallow clone of the option\n        var shallowClone = _extends({}, option);\n\n        if (!shallowClone.allOf) {\n          shallowClone.allOf = [];\n        } else {\n          // If \"allOf\" already exists, shallow clone the array\n          shallowClone.allOf = shallowClone.allOf.slice();\n        }\n\n        shallowClone.allOf.push(requiresAnyOf);\n        augmentedSchema = shallowClone;\n      } else {\n        augmentedSchema = Object.assign({}, option, requiresAnyOf);\n      } // Remove the \"required\" field as it's likely that not all fields have\n      // been filled in yet, which will mean that the schema is not valid\n\n\n      delete augmentedSchema.required;\n\n      if (isValid(augmentedSchema, formData, rootSchema)) {\n        return _i2;\n      }\n    } else if (isValid(option, formData, rootSchema)) {\n      return _i2;\n    }\n  }\n\n  return 0;\n} // Check to see if a schema specifies that a value must be true\n\nexport function schemaRequiresTrueValue(schema) {\n  // Check if const is a truthy value\n  if (schema[\"const\"]) {\n    return true;\n  } // Check if an enum has a single value of true\n\n\n  if (schema[\"enum\"] && schema[\"enum\"].length === 1 && schema[\"enum\"][0] === true) {\n    return true;\n  } // If anyOf has a single value, evaluate the subschema\n\n\n  if (schema.anyOf && schema.anyOf.length === 1) {\n    return schemaRequiresTrueValue(schema.anyOf[0]);\n  } // If oneOf has a single value, evaluate the subschema\n\n\n  if (schema.oneOf && schema.oneOf.length === 1) {\n    return schemaRequiresTrueValue(schema.oneOf[0]);\n  } // Evaluate each subschema in allOf, to see if one of them requires a true\n  // value\n\n\n  if (schema.allOf) {\n    return schema.allOf.some(schemaRequiresTrueValue);\n  }\n\n  return false;\n}"]},"metadata":{},"sourceType":"module"}